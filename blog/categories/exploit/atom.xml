<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: exploit | Core dump overflow]]></title>
  <link href="http://chousensha.github.io/blog/categories/exploit/atom.xml" rel="self"/>
  <link href="http://chousensha.github.io/"/>
  <updated>2014-07-04T22:38:55+03:00</updated>
  <id>http://chousensha.github.io/</id>
  <author>
    <name><![CDATA[chousensha]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SmashTheStack IO Level 2]]></title>
    <link href="http://chousensha.github.io/blog/2014/07/03/smashthestack-io-level-2/"/>
    <updated>2014-07-03T23:51:49+03:00</updated>
    <id>http://chousensha.github.io/blog/2014/07/03/smashthestack-io-level-2</id>
    <content type="html"><![CDATA[<p>For level 2, there are two programs that can be used to advance, and we have access to source code! Let&rsquo;s check the first one.</p>

<!-- more -->


<p>The source code for level02.c is as follows:</p>

<p>``` c
//a little fun brought to you by bla</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;signal.h></h1>

<h1>include &lt;setjmp.h></h1>

<p>void catcher(int a)
{</p>

<pre><code>    setresuid(geteuid(),geteuid(),geteuid());
printf("WIN!\n");
    system("/bin/sh");
    exit(0);
</code></pre>

<p>}</p>

<p>int main(int argc, char **argv)
{</p>

<pre><code>puts("source code is available in level02.c\n");

    if (argc != 3 || !atoi(argv[2]))
            return 1;
    signal(SIGFPE, catcher);
    return abs(atoi(argv[1])) / atoi(argv[2]);
</code></pre>

<p>}
```</p>

<h4>Function overview</h4>

<p><strong>atoi</strong></p>

<p><em>int atoi(const char *str);</em></p>

<p>Converts the string argument to an integer. The string must contain a valid integer number. If this is not the case, the returned value is undefined.</p>

<p>The number can be terminated by any character that cannot be part of an integer number. This includes white space, punctuation, and characters.</p>

<p>Returns 0 if the string can&rsquo;t be converted to a valid integer.</p>

<p><strong>abs</strong></p>

<p><em>int abs (int n);</em></p>

<p>Returns the absolute value of an integer.</p>

<p>Trying to take the absolute value of the most negative integer is not defined.</p>

<p><strong>signal</strong></p>

<p><em>typedef void (*sighandler_t)(int);</em></p>

<p><em>sighandler_t signal(int signum, sighandler_t handler);</em></p>

<p>Sets a function as a handler for the signal. That function will be called when the program receives the signal.</p>

<p>The function can be a specific function or one of the following macros:</p>

<p><strong>SIG_DFL</strong> Default signal handling: the default action associated with the signal occurs.</p>

<p><strong>SIG_IGN</strong> Ignore the signal</p>

<p>According  to  POSIX, the behavior of a process is undefined after it ignores a SIGFPE, SIGILL, or SIGSEGV signal that was not generated by kill(2) or raise(3).  Integer division by zero has undefined result.  On some architectures it will  generate  a  SIGFPE signal.  (Also dividing the most negative integer by -1 may generate SIGFPE.)  Ignoring this signal might lead to an endless loop.</p>

<p>The effects of signal() in a multithreaded process are unspecified.</p>

<p><strong>SIGFPE</strong>      (Signal Floating-Point Exception) Erroneous arithmetic operation, such as zero divide or an operation resulting in overflow (not necessarily with a floating-point operation).</p>

<h4>Program description</h4>

<p>We can see from the code that the program is looking for 2 arguments, with the second being a valid <em>atoi</em> converted integer, and it returns the absolute value of the result of the division between the first and second arguments. The <em>catcher</em> function is registered as handler for the SIGFPE signal, and we want it to get called. At first glance, this should be possible by doing a zero division. But we can&rsquo;t use 0 for our second argument, because the program checks for <em>atoi</em> returning 0.</p>

<p>From the man page, we know that SIGFPE may be generated if we divide the most negative integer by -1, so let&rsquo;s try that:</p>

<p>``` plain
level2@io:/levels$ ./level02 -2147483648 -1
source code is available in level02.c</p>

<p>WIN!
sh-4.2$ cat /home/level3/.pass
Ib3F7i7FqjziuDOBKi
```</p>

<p>It worked! Now let&rsquo;s look at the alternate way. This is the source for level02_alt.c:</p>

<p>``` c
/<em> submitted by noname </em>/</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>define answer 3.141593</h1>

<p>void main(int argc, char **argv) {</p>

<pre><code>float a = (argc - 2)?: strtod(argv[1], 0);

    printf("You provided the number %f which is too ", a);


    if(a &lt; answer)
             puts("low");
    else if(a &gt; answer)
            puts("high");
    else
            execl("/bin/sh", "sh", "-p", NULL);
</code></pre>

<p>}
```</p>

<h4>Function overview</h4>

<p><strong>strtod</strong></p>

<p><em>double strtod(const char *str, char **endptr);</em></p>

<p>Converts the string to double and returns the result. Any character that cannot be part of a floating-point number will end the parsing. A pointer to the rest of the string after the last valid character is stored in the object pointed by <em>endptr</em>. If no conversion is performed, 0 is returned and the value of <em>str</em> is stored in the location referenced by <em>endptr</em>.</p>

<h4>Program description</h4>

<p>The program will spawn a shell if we provide it with the exact match for answer. But it&rsquo;s not as straightforward as passing 3.141593 to it, when I did that, I got the message that it was too low. I added a printf to the code, and I couldn&rsquo;t see any difference in rounding, but since this is a no-go, there has to be something else. Looking more closely at the manpage:</p>

<blockquote><p>The expected form of the (initial portion of the) string is optional
leading white space as recognized by isspace(3), an optional plus (&lsquo;+&rsquo;)
or minus sign (&lsquo;&ndash;&rsquo;) and then either (i) a decimal number, or (ii) a
hexadecimal number, or (iii) an infinity, or (iv) a NAN (not-a-number).</p>

<p>A NAN is &ldquo;NAN&rdquo; (disregarding case) optionally followed by &lsquo;(&rsquo;, a
sequence of characters, followed by &lsquo;)&rsquo;.  The character string specifies in an implementation-dependent way the type of NAN.</p></blockquote>

<p>Passing it nan gives us the shell:</p>

<p><code>plain
level2@io:/levels$ ./level02_alt nan
sh-4.2$ whoami
level3
</code></p>

<p>Cookie:</p>

<blockquote><p>Your temporary financial embarrassment will be relieved in a surprising manner.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SmashTheStack IO Level 1]]></title>
    <link href="http://chousensha.github.io/blog/2014/07/03/smashthestack-io-level-1/"/>
    <updated>2014-07-03T19:24:36+03:00</updated>
    <id>http://chousensha.github.io/blog/2014/07/03/smashthestack-io-level-1</id>
    <content type="html"><![CDATA[<p>There are different wargames hosted on <a href="http://smashthestack.org/">http://smashthestack.org/</a> , with IO being the most popular of them. The missions revolve around debugging and reversing binaries in order to exploit some software vulnerabilities and gain enough privileges to read the password for the next level.</p>

<!-- more -->


<p>To connect to the first level, you have to SSH to the box with the password of <strong>level1</strong>:</p>

<p><code>plain
ssh level1@io.smashthestack.org
</code></p>

<p>If you are new to these wargames, read the README file, which has some additional explanations. Levels for this game can be found in <code>/levels</code> and passwords are located in the level&rsquo;s home directory, like <code>/home/level2/.pass</code></p>

<p>So, when trying to run the <em>level01</em> binary, we can see it&rsquo;s looking for a passcode:</p>

<p><code>plain
level1@io:/levels$ ./level01
Enter the 3 digit passcode to enter:
</code></p>

<p>Let&rsquo;s see what&rsquo;s going on using GDB. This is the disassembly of the main() function for this program:</p>

<p><code>plain
(gdb) disas main
Dump of assembler code for function main:
   0x08048080 &lt;+0&gt;:     push   $0x8049128
   0x08048085 &lt;+5&gt;:     call   0x804810f &lt;puts&gt;
   0x0804808a &lt;+10&gt;:    call   0x804809f &lt;fscanf&gt;
   0x0804808f &lt;+15&gt;:    cmp    $0x10f,%eax
   0x08048094 &lt;+20&gt;:    je     0x80480dc &lt;YouWin&gt;
   0x0804809a &lt;+26&gt;:    call   0x8048103 &lt;exit&gt;
End of assembler dump.
</code></p>

<p>This line is interesting:</p>

<p><strong>cmp    $0x10f,%eax</strong></p>

<p>So there is a comparison between a constant and <em>eax</em>, and if they&rsquo;re equal, it means that we&rsquo;re right on the password. Let&rsquo;s check that constant:</p>

<p><code>plain
(gdb) p 0x10f
$2 = 271
</code></p>

<p>This makes sense, 0x10f is the hex representation of 271 in decimal. And we know the program is looking for a 3-digit passcode. Let&rsquo;s try it:</p>

<p><code>plain
level1@io:/levels$ ./level01
Enter the 3 digit passcode to enter: 271
Congrats you found it, now read the password for level2 from /home/level2/.pass
sh-4.2$ cat /home/level2/.pass
hgvbmkQIHavkGg5wyk
</code></p>

<p>Ok, this was an easy level!</p>

<blockquote><p>Q:    How many hardware engineers does it take to change a light bulb?
A:    None.  We&rsquo;ll fix it in software.</p>

<p>Q:    How many system programmers does it take to change a light bulb?
A:    None.  The application can work around it.</p>

<p>Q:    How many software engineers does it take to change a light bulb?
A:    None.  We&rsquo;ll document it in the manual.</p>

<p>Q:    How many tech writers does it take to change a light bulb?
A:    None.  The user can figure it out.</p></blockquote>
]]></content>
  </entry>
  
</feed>
